# Story 1.2: Authentication Flow with Clerk

## Status

**Complete**

---

## Story

**As a** user,
**I want** to sign up and log in using email or social accounts,
**so that** my profile and progress are saved across sessions.

---

## Acceptance Criteria

1. Clerk integrated with Next.js middleware protecting authenticated routes
2. Sign up flow with email/password and Google OAuth options
3. Sign in flow with email/password and Google OAuth
4. Sign out functionality accessible from UI
5. User session persisted and accessible in server/client components
6. Unauthenticated users redirected to sign-in page when accessing protected routes
7. Clerk webhook syncs user creation to Convex users table

---

## Tasks / Subtasks

- [x] **Task 1: Install and Configure Clerk** (AC: 1)
  - [x] Install Clerk packages: `npm install @clerk/nextjs`
  - [x] Add Clerk environment variables to `.env.local`
  - [x] Update `.env.example` with new variables
  - [x] Create `middleware.ts` at project root with Clerk middleware

- [x] **Task 2: Setup Clerk Provider** (AC: 5)
  - [x] Update `app/providers.tsx` with `<ClerkProvider>` wrapping `<ConvexProviderWithClerk>`
  - [x] Ensure ClerkProvider wraps ConvexProvider (Clerk outside, Convex inside)

- [x] **Task 3: Create Auth Routes** (AC: 2, 3)
  - [x] Create `app/sign-in/[[...sign-in]]/page.tsx` with `<SignIn />` component
  - [x] Create `app/sign-up/[[...sign-up]]/page.tsx` with `<SignUp />` component
  - [x] Style auth pages to match RetroUI aesthetic (custom appearance)

- [x] **Task 4: Configure Route Protection** (AC: 1, 6)
  - [x] Define protected routes in middleware: `/dashboard`, `/corridor`, `/settings`, `/voice`
  - [x] Public routes remain accessible

- [x] **Task 5: Add Sign Out Functionality** (AC: 4)
  - [x] Add `<UserButton>` in dashboard with sign out functionality

- [x] **Task 6: Setup Clerk Webhook for Convex Sync** (AC: 7)
  - [x] Create `app/api/webhooks/clerk/route.ts`
  - [x] Install svix for webhook verification
  - [x] Verify webhook signature using `CLERK_WEBHOOK_SECRET`
  - [x] Handle `user.created` event → create user in Convex
  - [x] Handle `user.deleted` event → delete user from Convex

- [x] **Task 7: Create Convex User Mutations** (AC: 7)
  - [x] Create `convex/users.ts` with `createFromClerk`, `deleteByClerkId`, `getProfile`
  - [x] Add `updateLanguage` and `completeOnboarding` mutations

- [x] **Task 8: Integrate Clerk with Convex Client** (AC: 5)
  - [x] Create `convex/auth.config.ts` for JWT validation
  - [x] Update `app/providers.tsx` to use `ConvexProviderWithClerk`
  - [x] Set `CLERK_JWT_ISSUER_DOMAIN` in Convex dashboard

---

## Dev Notes

### Clerk + Convex Integration Pattern
[Source: architecture.md#frontend-architecture]

```typescript
// app/providers.tsx
"use client";

import { ClerkProvider, useAuth } from "@clerk/nextjs";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ClerkProvider>
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        {children}
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
}
```

### Middleware Configuration
[Source: architecture.md#routing-architecture]

```typescript
// middleware.ts
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isProtectedRoute = createRouteMatcher([
  "/dashboard(.*)",
  "/corridor(.*)",
  "/settings(.*)",
  "/voice(.*)",
]);

const isPublicRoute = createRouteMatcher([
  "/sign-in(.*)",
  "/sign-up(.*)",
  "/",
  "/api/webhooks(.*)",
  "/api/health",
]);

export default clerkMiddleware((auth, req) => {
  if (isProtectedRoute(req)) {
    auth().protect();
  }
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

### Webhook Handler Pattern
[Source: architecture.md#backend-architecture]

```typescript
// app/api/webhooks/clerk/route.ts
import { Webhook } from "svix";
import { headers } from "next/headers";
import { WebhookEvent } from "@clerk/nextjs/server";
import { ConvexHttpClient } from "convex/browser";
import { api } from "@/convex/_generated/api";

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export async function POST(req: Request) {
  const WEBHOOK_SECRET = process.env.CLERK_WEBHOOK_SECRET!;

  const headerPayload = headers();
  const svix_id = headerPayload.get("svix-id");
  const svix_timestamp = headerPayload.get("svix-timestamp");
  const svix_signature = headerPayload.get("svix-signature");

  const payload = await req.json();
  const body = JSON.stringify(payload);

  const wh = new Webhook(WEBHOOK_SECRET);
  let evt: WebhookEvent;

  try {
    evt = wh.verify(body, {
      "svix-id": svix_id!,
      "svix-timestamp": svix_timestamp!,
      "svix-signature": svix_signature!,
    }) as WebhookEvent;
  } catch (err) {
    return new Response("Webhook verification failed", { status: 400 });
  }

  if (evt.type === "user.created") {
    await convex.mutation(api.users.createFromClerk, {
      clerkId: evt.data.id,
      email: evt.data.email_addresses[0]?.email_address ?? "",
      name: `${evt.data.first_name ?? ""} ${evt.data.last_name ?? ""}`.trim(),
    });
  }

  if (evt.type === "user.deleted") {
    await convex.mutation(api.users.deleteByClerkId, {
      clerkId: evt.data.id!,
    });
  }

  return new Response("OK", { status: 200 });
}
```

### Convex Users Schema
[Source: architecture.md#database-schema]

```typescript
// convex/schema.ts (users table from Story 1.1)
users: defineTable({
  clerkId: v.string(),
  email: v.string(),
  name: v.string(),
  language: v.union(
    v.literal("en"),
    v.literal("yo"),
    v.literal("hi"),
    v.literal("pt"),
    v.literal("tl")
  ),
  onboardingComplete: v.boolean(),
  createdAt: v.number(),
})
  .index("by_clerk_id", ["clerkId"])
  .index("by_email", ["email"]),
```

### Environment Variables Required
[Source: architecture.md#appendix-a]

```bash
# Clerk (add to .env.local)
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxx
CLERK_SECRET_KEY=sk_test_xxx
CLERK_WEBHOOK_SECRET=whsec_xxx

# Clerk redirect URLs (set in Clerk Dashboard)
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/dashboard
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/dashboard
```

### Clerk Dashboard Configuration
1. Create Clerk application at clerk.com
2. Enable Google OAuth in Social Connections
3. Add webhook endpoint: `https://your-domain.vercel.app/api/webhooks/clerk`
4. Subscribe to events: `user.created`, `user.deleted`
5. Copy webhook signing secret to `CLERK_WEBHOOK_SECRET`

### File Locations
```
app/
├── sign-in/
│   └── [[...sign-in]]/
│       └── page.tsx          # Clerk SignIn component
├── sign-up/
│   └── [[...sign-up]]/
│       └── page.tsx          # Clerk SignUp component
├── api/
│   └── webhooks/
│       └── clerk/
│           └── route.ts      # Webhook handler
├── layout.tsx                # Updated with ClerkProvider
└── providers.tsx             # ConvexProviderWithClerk

components/
└── layout/
    └── UserMenu.tsx          # User dropdown with sign out

convex/
└── users.ts                  # User mutations

middleware.ts                 # Route protection
```

### Dependencies from Story 1.1
- Convex initialized and connected
- ConvexProvider working
- Users table in schema

---

## Testing

### Test File Location
Manual testing for auth flow; unit tests in later stories

### Testing Standards for This Story
[Source: architecture.md#testing-strategy]

Auth flows require manual verification:

### Manual Test Scenarios
1. **Sign Up Flow**
   - [ ] Navigate to `/sign-up`
   - [ ] Create account with email/password
   - [ ] Verify redirect to `/dashboard`
   - [ ] Check Convex dashboard: user created in users table

2. **Google OAuth**
   - [ ] Click "Sign up with Google"
   - [ ] Complete OAuth flow
   - [ ] Verify user created in Convex

3. **Sign In Flow**
   - [ ] Navigate to `/sign-in`
   - [ ] Sign in with existing credentials
   - [ ] Verify redirect to `/dashboard`

4. **Route Protection**
   - [ ] Sign out
   - [ ] Navigate to `/dashboard` directly
   - [ ] Verify redirect to `/sign-in`

5. **Sign Out**
   - [ ] Click user menu
   - [ ] Click sign out
   - [ ] Verify redirect to home or sign-in

6. **Webhook Sync**
   - [ ] Create new user
   - [ ] Check Convex users table has entry with clerkId
   - [ ] Delete user in Clerk dashboard
   - [ ] Verify user removed from Convex

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-21 | 1.0 | Initial story draft | Bob (SM) |
| 2025-12-21 | 1.1 | Implementation complete | James (Dev) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
- CLERK_JWT_ISSUER_DOMAIN needed to be set in both .env.local AND Convex Dashboard
- Used `npx convex env set` to configure Convex environment variable

### Completion Notes List
- @clerk/nextjs and svix installed for auth and webhook verification
- ClerkProvider wraps ConvexProviderWithClerk in providers.tsx
- Middleware protects /dashboard, /corridor, /settings, /voice routes
- Auth pages styled with RetroUI neobrutalist appearance
- Webhook handler syncs user.created and user.deleted events to Convex
- convex/auth.config.ts configures Clerk JWT validation
- All Clerk env vars added to Vercel production

### File List
**Created:**
- `apps/web/middleware.ts` - Clerk route protection middleware
- `apps/web/app/sign-in/[[...sign-in]]/page.tsx` - Sign in page
- `apps/web/app/sign-up/[[...sign-up]]/page.tsx` - Sign up page
- `apps/web/app/dashboard/page.tsx` - Protected dashboard page
- `apps/web/app/api/webhooks/clerk/route.ts` - Clerk webhook handler
- `apps/web/convex/users.ts` - User mutations and queries
- `apps/web/convex/auth.config.ts` - Clerk JWT configuration

**Modified:**
- `apps/web/app/providers.tsx` - Added ClerkProvider + ConvexProviderWithClerk
- `apps/web/.env.example` - Added CLERK_JWT_ISSUER_DOMAIN

---

## QA Results
*To be filled by QA Agent*
