# Story 6.1: Dynamic Content Translation with Google Cloud Translation

## Status

**Complete**

---

## Story

**As a** user viewing protocols and Q&A responses,
**I want** dynamic content translated to my selected language in real-time,
**so that** I can understand all migration intelligence regardless of the original content language.

---

## Acceptance Criteria

1. Dynamic content (protocols, Q&A responses, audio scripts) translated via Google Cloud Translation API
2. Translations cached using content-hash deduplication in Convex
3. Cache hit rate tracked and optimized (target: >80%)
4. Supported languages: English, Spanish, Portuguese, French, German, Yoruba, Hindi, Tagalog, Korean (9 locales)
5. Translation fallback to original content if API fails
6. Content freshness indicators show when translations were last updated
7. Usage tracking for cost monitoring ($20/million characters)
8. Batch translation support for protocol lists (reduce API calls)

---

## Tasks / Subtasks

- [x] **Task 1: Add Translation Schema** (AC: 2, 3)
  - [x] Add `translations` table to `convex/schema.ts`
  - [x] Fields: hash, originalText, translatedText, sourceLocale, targetLocale, charCount, createdAt, expiresAt
  - [x] Indexes: by_hash, by_expiry, by_locale_pair
  - [x] Run `npx convex dev` to deploy schema

- [x] **Task 2: Create Translation Service** (AC: 1, 5)
  - [x] Create translation service in `convex/ai/translation.ts` (using REST API)
  - [x] Use Google Cloud Translation REST API (no npm package needed)
  - [x] Implement `callGoogleTranslate()` function
  - [x] Add error handling with fallback to original
  - [x] Implement content-hash generation (SHA256)

- [x] **Task 3: Create Translation Convex Action** (AC: 1, 2, 8)
  - [x] Create `convex/ai/translation.ts` with Node.js runtime
  - [x] Implement `translateContent` action
  - [x] Check cache before API call
  - [x] Store translation in cache on miss
  - [x] Implement `batchTranslate` for protocol lists

- [x] **Task 4: Add Translation Caching Queries** (AC: 2, 3)
  - [x] Create `getCached` query in `convex/translation.ts`
  - [x] Create `getCacheStats` query (hit rate, total chars)
  - [x] Create `cleanExpired` internal mutation

- [x] **Task 5: Integrate with Protocol Display** (AC: 1, 6)
  - [x] Update `ProtocolCard.tsx` to use translated content
  - [x] Add `useTranslatedProtocol` hook
  - [x] Show Languages icon on translated content
  - [x] Show Loader2 spinner during translation

- [x] **Task 6: Add Usage Tracking** (AC: 7)
  - [x] Track character count per translation
  - [x] Create `getUsageStats` query (daily breakdown)
  - [x] Estimated cost calculation ($20/million chars)

- [x] **Task 7: Add Freshness Constants** (AC: 6)
  - [x] Update `lib/constants/freshness.ts` with translation TTL
  - [x] Define TTL for different content types
  - [x] Protocol translations: 7 days
  - [x] Q&A responses: 24 hours

- [x] **Task 8: Create Scheduled Cleanup Cron** (AC: 2)
  - [x] Add cron job to `convex/crons.ts`
  - [x] Clean expired translations daily at 3:30 AM UTC
  - [x] Returns deleted count and freed characters

---

## Dev Notes

### Why Google Cloud Translation (Not DeepL)

**Critical Decision:** DeepL API does NOT support Yoruba, Hindi, or Tagalog - three of TRIBE's core languages. Google Cloud Translation supports 130+ languages including all 9 TRIBE locales.

**Cost Analysis:**
- Google Cloud: $20/million characters
- DeepL: $25/million characters (and missing language support)
- With 80% cache hit rate, estimated monthly cost: $5-15

### Translation Schema
```typescript
// convex/schema.ts - Add translations table
translations: defineTable({
  hash: v.string(),              // SHA256 hash of content + target locale
  originalText: v.string(),
  translatedText: v.string(),
  sourceLocale: v.string(),
  targetLocale: v.string(),
  charCount: v.number(),         // For usage tracking
  createdAt: v.number(),
  expiresAt: v.number(),         // TTL for cache invalidation
})
  .index("by_hash", ["hash"])
  .index("by_expiry", ["expiresAt"])
  .index("by_locale_pair", ["sourceLocale", "targetLocale"]),
```

### Translation Service
```typescript
// lib/api/translation.ts
import { TranslationServiceClient } from "@google-cloud/translate";
import { createHash } from "crypto";

const translationClient = new TranslationServiceClient();
const projectId = process.env.GOOGLE_CLOUD_PROJECT_ID;

export function getContentHash(text: string, targetLang: string): string {
  return createHash("sha256")
    .update(`${text}:${targetLang}`)
    .digest("hex")
    .slice(0, 16);
}

export async function translateText(
  text: string,
  targetLang: string,
  sourceLang: string = "en"
): Promise<string> {
  try {
    const [response] = await translationClient.translateText({
      parent: `projects/${projectId}/locations/global`,
      contents: [text],
      mimeType: "text/plain",
      sourceLanguageCode: sourceLang,
      targetLanguageCode: targetLang,
    });

    return response.translations?.[0]?.translatedText ?? text;
  } catch (error) {
    console.error("Translation failed, returning original:", error);
    return text; // Fallback to original
  }
}
```

### Convex Translation Action
```typescript
// convex/ai/translation.ts
import { action, query, mutation } from "../_generated/server";
import { v } from "convex/values";
import { api } from "../_generated/api";
import { getContentHash, translateText } from "../../lib/api/translation";

const TRANSLATION_TTL_DAYS = 7;

export const translateContent = action({
  args: {
    text: v.string(),
    targetLocale: v.string(),
    sourceLocale: v.optional(v.string()),
  },
  handler: async (ctx, { text, targetLocale, sourceLocale = "en" }) => {
    // Skip if same language
    if (targetLocale === sourceLocale) {
      return { text, cached: true, translated: false };
    }

    // Check cache first
    const hash = getContentHash(text, targetLocale);
    const cached = await ctx.runQuery(api.ai.translation.getCached, { hash });

    if (cached) {
      return { text: cached.translatedText, cached: true, translated: true };
    }

    // Call Google Cloud Translation
    const translatedText = await translateText(text, targetLocale, sourceLocale);

    // Store in cache
    await ctx.runMutation(api.ai.translation.cacheTranslation, {
      hash,
      originalText: text,
      translatedText,
      sourceLocale,
      targetLocale,
      charCount: text.length,
    });

    return { text: translatedText, cached: false, translated: true };
  },
});

export const batchTranslate = action({
  args: {
    texts: v.array(v.string()),
    targetLocale: v.string(),
    sourceLocale: v.optional(v.string()),
  },
  handler: async (ctx, { texts, targetLocale, sourceLocale = "en" }) => {
    if (targetLocale === sourceLocale) {
      return texts.map((text) => ({ text, cached: true }));
    }

    // Check cache for all texts
    const results: { text: string; cached: boolean }[] = [];
    const toTranslate: { index: number; text: string; hash: string }[] = [];

    for (let i = 0; i < texts.length; i++) {
      const hash = getContentHash(texts[i], targetLocale);
      const cached = await ctx.runQuery(api.ai.translation.getCached, { hash });

      if (cached) {
        results[i] = { text: cached.translatedText, cached: true };
      } else {
        toTranslate.push({ index: i, text: texts[i], hash });
      }
    }

    // Batch translate uncached texts
    if (toTranslate.length > 0) {
      const textsToTranslate = toTranslate.map((t) => t.text);

      // Google Cloud supports batch translation
      const translated = await Promise.all(
        textsToTranslate.map((text) => translateText(text, targetLocale, sourceLocale))
      );

      // Cache and store results
      for (let i = 0; i < toTranslate.length; i++) {
        const { index, text, hash } = toTranslate[i];
        const translatedText = translated[i];

        await ctx.runMutation(api.ai.translation.cacheTranslation, {
          hash,
          originalText: text,
          translatedText,
          sourceLocale,
          targetLocale,
          charCount: text.length,
        });

        results[index] = { text: translatedText, cached: false };
      }
    }

    return results;
  },
});

export const getCached = query({
  args: { hash: v.string() },
  handler: async (ctx, { hash }) => {
    return ctx.db
      .query("translations")
      .withIndex("by_hash", (q) => q.eq("hash", hash))
      .first();
  },
});

export const cacheTranslation = mutation({
  args: {
    hash: v.string(),
    originalText: v.string(),
    translatedText: v.string(),
    sourceLocale: v.string(),
    targetLocale: v.string(),
    charCount: v.number(),
  },
  handler: async (ctx, args) => {
    const expiresAt = Date.now() + TRANSLATION_TTL_DAYS * 24 * 60 * 60 * 1000;

    return ctx.db.insert("translations", {
      ...args,
      createdAt: Date.now(),
      expiresAt,
    });
  },
});

export const getCacheStats = query({
  args: {},
  handler: async (ctx) => {
    const translations = await ctx.db.query("translations").collect();

    const totalChars = translations.reduce((sum, t) => sum + t.charCount, 0);
    const byLocale = translations.reduce((acc, t) => {
      const key = `${t.sourceLocale}->${t.targetLocale}`;
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      totalTranslations: translations.length,
      totalCharacters: totalChars,
      estimatedCost: (totalChars / 1_000_000) * 20, // $20/million chars
      byLocalePair: byLocale,
    };
  },
});

export const cleanExpired = mutation({
  args: {},
  handler: async (ctx) => {
    const now = Date.now();
    const expired = await ctx.db
      .query("translations")
      .withIndex("by_expiry")
      .filter((q) => q.lt(q.field("expiresAt"), now))
      .collect();

    let deleted = 0;
    for (const translation of expired) {
      await ctx.db.delete(translation._id);
      deleted++;
    }

    return { deleted, timestamp: now };
  },
});
```

### Freshness Constants
```typescript
// lib/constants/freshness.ts
export const FRESHNESS_TTL = {
  PROTOCOL: 7 * 24 * 60 * 60 * 1000,      // 7 days
  QA_RESPONSE: 24 * 60 * 60 * 1000,        // 24 hours
  AUDIO_SCRIPT: 12 * 60 * 60 * 1000,       // 12 hours
  CORRIDOR_DATA: 24 * 60 * 60 * 1000,      // 24 hours
} as const;

export const STALE_THRESHOLD = {
  PROTOCOL: 5 * 24 * 60 * 60 * 1000,       // Show "updating" after 5 days
  QA_RESPONSE: 18 * 60 * 60 * 1000,        // Show "updating" after 18 hours
} as const;
```

### useTranslatedProtocol Hook
```typescript
// hooks/useTranslatedProtocol.ts
import { useAction, useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useLocale } from "next-intl";
import { useState, useEffect } from "react";

export function useTranslatedProtocol(protocol: Protocol) {
  const locale = useLocale();
  const translateAction = useAction(api.ai.translation.translateContent);
  const [translated, setTranslated] = useState(protocol);
  const [isTranslating, setIsTranslating] = useState(false);

  useEffect(() => {
    if (locale === "en") {
      setTranslated(protocol);
      return;
    }

    async function translate() {
      setIsTranslating(true);
      try {
        const [titleResult, descResult] = await Promise.all([
          translateAction({ text: protocol.title, targetLocale: locale }),
          translateAction({ text: protocol.description, targetLocale: locale }),
        ]);

        setTranslated({
          ...protocol,
          title: titleResult.text,
          description: descResult.text,
        });
      } finally {
        setIsTranslating(false);
      }
    }

    translate();
  }, [protocol._id, locale]);

  return { protocol: translated, isTranslating };
}
```

### Cron Job for Cleanup
```typescript
// convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Clean expired translations daily at 3 AM UTC
crons.daily(
  "clean expired translations",
  { hourUTC: 3, minuteUTC: 0 },
  internal.ai.translation.cleanExpired
);

export default crons;
```

### File Structure
```
lib/
├── api/
│   └── translation.ts        # Google Cloud Translation client
├── constants/
│   └── freshness.ts          # TTL constants

convex/
└── ai/
    └── translation.ts        # Translation actions & mutations

hooks/
└── useTranslatedProtocol.ts  # React hook for translation
```

### Environment Variables
```bash
# Add to Convex environment
npx convex env set GOOGLE_CLOUD_PROJECT_ID=your-project-id
npx convex env set GOOGLE_CLOUD_API_KEY=your-api-key
```

### Dependencies from Previous Stories
- Story 1.5: User profile with language preference
- Story 2.4: Protocol Synthesis (content to translate)
- Story 3.3: Source Attribution (translatable attribution text)

---

## Testing

### Test Scenarios

1. **Translation API**
   - [ ] Single text translated correctly
   - [ ] Batch translation works for multiple texts
   - [ ] Fallback to original on API error

2. **Caching**
   - [ ] Cache hit returns stored translation
   - [ ] Cache miss triggers API call
   - [ ] Same content generates same hash

3. **Language Support**
   - [ ] English (source) works
   - [ ] Spanish translation works
   - [ ] Portuguese translation works
   - [ ] Yoruba translation works
   - [ ] Hindi translation works
   - [ ] Tagalog translation works
   - [ ] Korean translation works

4. **Performance**
   - [ ] Batch translation reduces API calls
   - [ ] Cache hit rate >80% after warmup
   - [ ] Translation latency <500ms (cached)

5. **Cleanup**
   - [ ] Expired translations deleted by cron
   - [ ] Cache stats accurate

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-22 | 1.0 | Initial story draft | Claude |

---

## Dev Agent Record

### Implementation Summary

Implemented dynamic content translation using Google Cloud Translation API with caching for cost optimization.

### Files Created
- `convex/translation.ts` - Queries and mutations for translation caching (V8 runtime)
- `convex/ai/translation.ts` - Translation actions using Node.js runtime with Google Cloud Translation REST API
- `hooks/useTranslatedProtocol.ts` - React hook for translating protocol content

### Files Modified
- `convex/schema.ts` - Added `translations` table with hash, content, locale, and TTL fields
- `convex/crons.ts` - Added daily cleanup cron for expired translations
- `lib/constants/freshness.ts` - Added TRANSLATION_TTL and STALE_THRESHOLD constants
- `components/protocol/ProtocolCard.tsx` - Integrated translation hook with visual indicators

### Technical Decisions
1. **Convex File Split**: Separated actions (Node.js runtime) from queries/mutations (V8 runtime) due to Convex requirements
2. **Google Cloud REST API**: Used direct REST API calls instead of npm package to work within Convex action constraints
3. **Content Hashing**: SHA256 hash of text + targetLocale for cache key deduplication
4. **Batch Translation**: Implemented parallel translation with cache-first strategy to minimize API calls
5. **Visual Feedback**: Languages icon shows when content is translated, Loader2 spinner during translation

### API Configuration Required
```bash
npx convex env set GOOGLE_CLOUD_API_KEY=your-api-key
```

### Supported Languages
All 9 TRIBE locales are supported by Google Cloud Translation:
- English (en), Spanish (es), Portuguese (pt), French (fr), German (de)
- Yoruba (yo), Hindi (hi), Tagalog (tl), Korean (ko)

### Cost Tracking
- $20/million characters
- `getCacheStats` query returns estimated cost
- `getUsageStats` query provides daily breakdown

### Completion Date
2025-12-23

---

## QA Results
*To be filled by QA Agent*
