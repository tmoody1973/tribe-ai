# Story 2.1: Convex Schema for Corridors & Protocols

## Status

**Complete**

---

## Story

**As a** developer,
**I want** a data model for corridors, protocols, and ingested content,
**so that** synthesized intelligence can be stored and retrieved efficiently.

---

## Acceptance Criteria

1. Corridors table with: id, originCountry, destinationCountry, lastResearched, sourceCount, status
2. Protocols table with: id, corridorId, sequence (array of steps), createdAt, updatedAt
3. ProtocolSteps embedded structure with: order, title, description, warnings, hacks, attribution
4. Attribution structure with: authorName, sourceUrl, sourceDate, engagement score
5. IngestedContent table for raw scraped content with: corridorId, sourceUrl, content, scrapedAt
6. Indexes on corridorId and origin+destination for efficient queries
7. TypeScript types generated and exported for frontend use

---

## Tasks / Subtasks

- [ ] **Task 1: Create Corridors Table** (AC: 1, 6)
  - [ ] Add corridors table to `convex/schema.ts`
  - [ ] Fields: userId, origin, destination, stage, createdAt, updatedAt
  - [ ] Add index `by_user` on userId
  - [ ] Add index `by_corridor` on [origin, destination]
  - [ ] Run `npx convex dev` to apply changes

- [ ] **Task 2: Create Protocols Table** (AC: 2, 3, 4, 6)
  - [ ] Add protocols table to `convex/schema.ts`
  - [ ] Fields: corridorId, category, title, description, status, priority, order
  - [ ] Add warnings array field
  - [ ] Add hacks/tips array field
  - [ ] Add attribution object with authorName, sourceUrl, sourceDate, engagement
  - [ ] Add index `by_corridor` on corridorId
  - [ ] Add index `by_status` on [corridorId, status]
  - [ ] Add index `by_category` on [corridorId, category]

- [ ] **Task 3: Create IngestedContent Table** (AC: 5, 6)
  - [ ] Add ingestedContent table to `convex/schema.ts`
  - [ ] Fields: corridorId, url, title, content, embedding, source, metadata
  - [ ] Add scrapedAt and expiresAt timestamp fields
  - [ ] Add index `by_corridor` on corridorId
  - [ ] Add index `by_url` on url
  - [ ] Add index `by_expiry` on expiresAt
  - [ ] Add vectorIndex `by_embedding` with 1024 dimensions

- [ ] **Task 4: Create Corridor CRUD Functions** (AC: 1)
  - [ ] Create `convex/corridors.ts`
  - [ ] Add `createCorridor` mutation
  - [ ] Add `getCorridor` query
  - [ ] Add `getUserCorridors` query
  - [ ] Add `getActiveCorridor` query (most recent for user)
  - [ ] Add `updateCorridor` mutation

- [ ] **Task 5: Create Protocol CRUD Functions** (AC: 2)
  - [ ] Create `convex/protocols.ts`
  - [ ] Add `createProtocol` mutation
  - [ ] Add `getProtocols` query (by corridorId)
  - [ ] Add `updateProtocolStatus` mutation
  - [ ] Add `batchCreateProtocols` mutation for initial generation

- [ ] **Task 6: Create IngestedContent Functions** (AC: 5)
  - [ ] Create `convex/ingestedContent.ts`
  - [ ] Add `storeContent` mutation
  - [ ] Add `getContentByCorridor` query
  - [ ] Add `getExpiredContent` query
  - [ ] Add `deleteExpiredContent` mutation

- [ ] **Task 7: Export TypeScript Types** (AC: 7)
  - [ ] Verify `convex/_generated/` types are generated
  - [ ] Create `packages/shared/src/types/corridor.ts` with re-exports
  - [ ] Create `packages/shared/src/types/protocol.ts` with re-exports
  - [ ] Export category and status union types for frontend use

---

## Dev Notes

### Complete Schema Definition
[Source: architecture.md#database-schema]

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Users table (from Epic 1)
  users: defineTable({
    clerkId: v.string(),
    email: v.string(),
    name: v.string(),
    language: v.union(
      v.literal("en"),
      v.literal("yo"),
      v.literal("hi"),
      v.literal("pt"),
      v.literal("tl")
    ),
    originCountry: v.optional(v.string()),
    destinationCountry: v.optional(v.string()),
    stage: v.optional(v.union(
      v.literal("dreaming"),
      v.literal("planning"),
      v.literal("preparing"),
      v.literal("relocating"),
      v.literal("settling")
    )),
    visaType: v.optional(v.string()),
    onboardingComplete: v.boolean(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_clerk_id", ["clerkId"])
    .index("by_email", ["email"]),

  // Corridors table (NEW)
  corridors: defineTable({
    userId: v.id("users"),
    origin: v.string(),        // ISO 3166-1 alpha-2
    destination: v.string(),   // ISO 3166-1 alpha-2
    stage: v.union(
      v.literal("dreaming"),
      v.literal("planning"),
      v.literal("preparing"),
      v.literal("relocating"),
      v.literal("settling")
    ),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_corridor", ["origin", "destination"]),

  // Protocols table (NEW)
  protocols: defineTable({
    corridorId: v.id("corridors"),
    category: v.union(
      v.literal("visa"),
      v.literal("finance"),
      v.literal("housing"),
      v.literal("employment"),
      v.literal("legal"),
      v.literal("health"),
      v.literal("social")
    ),
    title: v.string(),
    description: v.string(),
    status: v.union(
      v.literal("not_started"),
      v.literal("in_progress"),
      v.literal("completed"),
      v.literal("blocked")
    ),
    priority: v.union(
      v.literal("critical"),
      v.literal("high"),
      v.literal("medium"),
      v.literal("low")
    ),
    warnings: v.optional(v.array(v.string())),
    hacks: v.optional(v.array(v.string())),
    attribution: v.optional(v.object({
      authorName: v.optional(v.string()),
      sourceUrl: v.string(),
      sourceDate: v.optional(v.number()),
      engagement: v.optional(v.number()),
    })),
    dueDate: v.optional(v.number()),
    completedAt: v.optional(v.number()),
    aiGenerated: v.boolean(),
    order: v.number(),
  })
    .index("by_corridor", ["corridorId"])
    .index("by_status", ["corridorId", "status"])
    .index("by_category", ["corridorId", "category"]),

  // IngestedContent table (NEW)
  ingestedContent: defineTable({
    corridorId: v.id("corridors"),
    url: v.string(),
    title: v.string(),
    content: v.string(),
    embedding: v.array(v.float64()),  // 1024 dimensions (Voyage AI)
    source: v.union(
      v.literal("reddit"),
      v.literal("forum"),
      v.literal("blog"),
      v.literal("government"),
      v.literal("news")
    ),
    metadata: v.object({
      author: v.optional(v.string()),
      publishedAt: v.optional(v.number()),
      subreddit: v.optional(v.string()),
    }),
    scrapedAt: v.number(),
    expiresAt: v.number(),
  })
    .index("by_corridor", ["corridorId"])
    .index("by_url", ["url"])
    .index("by_expiry", ["expiresAt"])
    .vectorIndex("by_embedding", {
      vectorField: "embedding",
      dimensions: 1024,
      filterFields: ["corridorId"],
    }),
});
```

### Corridor Functions
[Source: architecture.md#api-specification]

```typescript
// convex/corridors.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const createCorridor = mutation({
  args: {
    origin: v.string(),
    destination: v.string(),
    stage: v.union(
      v.literal("dreaming"),
      v.literal("planning"),
      v.literal("preparing"),
      v.literal("relocating"),
      v.literal("settling")
    ),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .unique();

    if (!user) throw new Error("User not found");

    return await ctx.db.insert("corridors", {
      userId: user._id,
      origin: args.origin,
      destination: args.destination,
      stage: args.stage,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
  },
});

export const getCorridor = query({
  args: { id: v.id("corridors") },
  handler: async (ctx, { id }) => {
    return await ctx.db.get(id);
  },
});

export const getUserCorridors = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .unique();

    if (!user) return [];

    return await ctx.db
      .query("corridors")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .collect();
  },
});

export const getActiveCorridor = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .unique();

    if (!user) return null;

    // Return most recently updated corridor
    const corridors = await ctx.db
      .query("corridors")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .collect();

    return corridors.sort((a, b) => b.updatedAt - a.updatedAt)[0] ?? null;
  },
});
```

### Protocol Functions
[Source: architecture.md#api-specification]

```typescript
// convex/protocols.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const getProtocols = query({
  args: { corridorId: v.id("corridors") },
  handler: async (ctx, { corridorId }) => {
    return await ctx.db
      .query("protocols")
      .withIndex("by_corridor", (q) => q.eq("corridorId", corridorId))
      .collect();
  },
});

export const updateProtocolStatus = mutation({
  args: {
    id: v.id("protocols"),
    status: v.union(
      v.literal("not_started"),
      v.literal("in_progress"),
      v.literal("completed"),
      v.literal("blocked")
    ),
  },
  handler: async (ctx, { id, status }) => {
    const updates: any = { status };
    if (status === "completed") {
      updates.completedAt = Date.now();
    }
    await ctx.db.patch(id, updates);
  },
});

export const batchCreateProtocols = mutation({
  args: {
    corridorId: v.id("corridors"),
    protocols: v.array(v.object({
      category: v.string(),
      title: v.string(),
      description: v.string(),
      priority: v.string(),
      order: v.number(),
      warnings: v.optional(v.array(v.string())),
      hacks: v.optional(v.array(v.string())),
      attribution: v.optional(v.object({
        authorName: v.optional(v.string()),
        sourceUrl: v.string(),
        sourceDate: v.optional(v.number()),
        engagement: v.optional(v.number()),
      })),
    })),
  },
  handler: async (ctx, { corridorId, protocols }) => {
    const ids = [];
    for (const protocol of protocols) {
      const id = await ctx.db.insert("protocols", {
        corridorId,
        category: protocol.category as any,
        title: protocol.title,
        description: protocol.description,
        status: "not_started",
        priority: protocol.priority as any,
        order: protocol.order,
        warnings: protocol.warnings,
        hacks: protocol.hacks,
        attribution: protocol.attribution,
        aiGenerated: true,
      });
      ids.push(id);
    }
    return ids;
  },
});
```

### Vector Index Configuration
[Source: architecture.md#database-schema]

The vector index uses:
- **Voyage AI embeddings**: voyage-3 model, 1024 dimensions
- **Filter field**: corridorId for scoped searches
- Searches will always filter by corridor to prevent cross-corridor data leakage

### Type Exports
[Source: architecture.md#coding-standards]

```typescript
// packages/shared/src/types/corridor.ts
import type { Doc, Id } from "../../../convex/_generated/dataModel";

export type Corridor = Doc<"corridors">;
export type CorridorId = Id<"corridors">;

export type MigrationStage =
  | "dreaming"
  | "planning"
  | "preparing"
  | "relocating"
  | "settling";
```

```typescript
// packages/shared/src/types/protocol.ts
import type { Doc, Id } from "../../../convex/_generated/dataModel";

export type Protocol = Doc<"protocols">;
export type ProtocolId = Id<"protocols">;

export type ProtocolCategory =
  | "visa"
  | "finance"
  | "housing"
  | "employment"
  | "legal"
  | "health"
  | "social";

export type ProtocolStatus =
  | "not_started"
  | "in_progress"
  | "completed"
  | "blocked";

export type ProtocolPriority =
  | "critical"
  | "high"
  | "medium"
  | "low";
```

### File Structure
```
convex/
├── schema.ts              # Updated with corridors, protocols, ingestedContent
├── corridors.ts           # Corridor CRUD
├── protocols.ts           # Protocol CRUD
└── ingestedContent.ts     # Content storage

packages/
└── shared/
    └── src/
        └── types/
            ├── corridor.ts
            └── protocol.ts
```

### Dependencies from Epic 1
- Users table and authentication working
- Convex connected and functional

---

## Testing

### Test Scenarios

1. **Schema Validation**
   - [ ] Run `npx convex dev` without errors
   - [ ] All tables created in Convex dashboard
   - [ ] Indexes visible in dashboard

2. **Corridor CRUD**
   - [ ] Create corridor: `createCorridor({ origin: "NG", destination: "DE", stage: "planning" })`
   - [ ] Get corridor by ID
   - [ ] Get all corridors for user
   - [ ] Verify userId populated correctly

3. **Protocol CRUD**
   - [ ] Batch create protocols for a corridor
   - [ ] Get protocols by corridorId
   - [ ] Update protocol status to "completed"
   - [ ] Verify completedAt timestamp set

4. **Vector Index**
   - [ ] Verify vectorIndex created (visible in Convex dashboard)
   - [ ] Note: actual vector search tested in Story 2.3

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-21 | 1.0 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5

### Debug Log References
- Fixed vector search type error by using standard query instead of vectorSearch action
- Resolved Convex production deployment by setting CLERK_JWT_ISSUER_DOMAIN env var
- Created type exports in lib/types/ instead of packages/shared (no packages directory in project)

### Completion Notes List
- All 7 tasks completed
- Schema extended with corridors, protocols, ingestedContent tables
- Vector index configured with 1024 dimensions for Voyage AI embeddings
- Full CRUD functions created for all tables
- TypeScript types exported with label mappings
- Vector search deferred to Story 2.3 (using getRecentContent for now)

### File List
- `apps/web/convex/schema.ts` (modified - added 3 tables)
- `apps/web/convex/corridors.ts` (new)
- `apps/web/convex/protocols.ts` (new)
- `apps/web/convex/ingestedContent.ts` (new)
- `apps/web/lib/types/corridor.ts` (new)
- `apps/web/lib/types/protocol.ts` (new)
- `apps/web/lib/types/index.ts` (new)

---

## QA Results
*To be filled by QA Agent*
