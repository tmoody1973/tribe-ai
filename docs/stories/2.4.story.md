# Story 2.4: Protocol Synthesis Pipeline

## Status

**Draft**

---

## Story

**As a** system,
**I want** to synthesize raw research into sequenced protocols,
**so that** users receive actionable, ordered steps rather than raw data.

---

## Acceptance Criteria

1. Claude API integration for synthesis calls
2. Synthesis prompt extracts: tasks, sequence signals, success/failure patterns, warnings, hacks
3. Dependency graph constructed from sequence signals
4. Protocol steps ordered by dependency (topological sort)
5. Best attribution attached to each step (highest engagement + specificity)
6. Synthesized protocol saved to Convex protocols table
7. Synthesis handles multilingual output based on target language parameter

---

## Tasks / Subtasks

- [ ] **Task 1: Create Protocol Synthesizer Agent** (AC: 1, 2)
  - [ ] Create `agents/protocolSynthesizer.ts`
  - [ ] Configure with Claude Sonnet 4 model
  - [ ] Write synthesis system prompt
  - [ ] Define structured output schema for protocols
  - [ ] Handle multi-step extraction

- [ ] **Task 2: Create Synthesis Prompt** (AC: 2)
  - [ ] Design prompt to extract: tasks, sequences, warnings, hacks
  - [ ] Include examples of expected output format
  - [ ] Add instructions for dependency detection
  - [ ] Include attribution extraction rules

- [ ] **Task 3: Implement Dependency Graph** (AC: 3, 4)
  - [ ] Create `lib/graph/dependencyGraph.ts`
  - [ ] Parse sequence signals from synthesis output
  - [ ] Build directed acyclic graph (DAG)
  - [ ] Implement topological sort for ordering
  - [ ] Handle circular dependency detection

- [ ] **Task 4: Create Attribution Scorer** (AC: 5)
  - [ ] Create `lib/scoring/attribution.ts`
  - [ ] Score by: recency, engagement (upvotes), specificity
  - [ ] Select best attribution per protocol step
  - [ ] Handle multiple sources per step

- [ ] **Task 5: Create Synthesis Action** (AC: 6)
  - [ ] Create `convex/ai/synthesis.ts`
  - [ ] Implement `synthesizeProtocols` action
  - [ ] Fetch ingested content for corridor
  - [ ] Call protocol synthesizer agent
  - [ ] Order steps and attach attributions
  - [ ] Save to protocols table via batchCreateProtocols

- [ ] **Task 6: Implement Multilingual Synthesis** (AC: 7)
  - [ ] Accept `targetLanguage` parameter
  - [ ] Add translation instructions to prompt
  - [ ] Verify output in target language
  - [ ] Handle language codes: en, yo, hi, pt, tl

- [ ] **Task 7: Create Full Pipeline Action** (AC: 1-7)
  - [ ] Create `convex/ai/pipeline.ts`
  - [ ] Implement `generateCorridorProtocols` action
  - [ ] Chain: research → synthesis → storage
  - [ ] Handle errors at each stage
  - [ ] Return protocol IDs on success

---

## Dev Notes

### Protocol Synthesizer Agent
[Source: architecture.md#backend-architecture]

```typescript
// agents/protocolSynthesizer.ts
import { Agent } from "@mastra/core";

export const protocolSynthesizer = new Agent({
  name: "ProtocolSynthesizer",
  model: "claude-sonnet-4-20250514",
  instructions: `You are a protocol synthesis specialist for TRIBE.

Your role is to transform raw migration research into structured, actionable protocol steps.

INPUT: Raw research content about a migration corridor (origin → destination)

OUTPUT: Structured protocol steps in JSON format

EXTRACTION RULES:

1. IDENTIFY TASKS
   - Extract concrete actions migrants must take
   - Each task should be specific and actionable
   - Include time estimates when mentioned

2. DETECT SEQUENCES
   - Look for "before", "after", "first", "then", "once you have"
   - Identify dependencies: "You need X before you can Y"
   - Note parallel tasks that can happen simultaneously

3. EXTRACT WARNINGS
   - Common mistakes: "Don't make the mistake of..."
   - Pitfalls: "Many people fail because..."
   - Critical requirements: "You MUST have..."

4. EXTRACT HACKS/TIPS
   - Time savers: "A faster way is..."
   - Cost savers: "You can save money by..."
   - Insider knowledge: "What they don't tell you..."

5. ATTRIBUTION
   - Note the source URL for each piece of information
   - Include author/username when available
   - Record engagement metrics (upvotes, likes)

OUTPUT FORMAT:
{
  "protocols": [
    {
      "category": "visa|finance|housing|employment|legal|health|social",
      "title": "Short action title",
      "description": "Detailed description of what to do",
      "priority": "critical|high|medium|low",
      "dependsOn": ["title of prerequisite step"],
      "warnings": ["warning 1", "warning 2"],
      "hacks": ["tip 1", "tip 2"],
      "attribution": {
        "sourceUrl": "https://...",
        "authorName": "username",
        "engagement": 150
      }
    }
  ]
}`,
  tools: [],
});
```

### Synthesis Action
[Source: architecture.md#core-workflows]

```typescript
// convex/ai/synthesis.ts
import { action } from "../_generated/server";
import { v } from "convex/values";
import { api } from "../_generated/api";
import { protocolSynthesizer } from "../../agents/protocolSynthesizer";
import { buildDependencyGraph, topologicalSort } from "../../lib/graph/dependencyGraph";
import { selectBestAttribution } from "../../lib/scoring/attribution";

interface RawProtocol {
  category: string;
  title: string;
  description: string;
  priority: string;
  dependsOn?: string[];
  warnings?: string[];
  hacks?: string[];
  attribution?: {
    sourceUrl: string;
    authorName?: string;
    engagement?: number;
  };
}

export const synthesizeProtocols = action({
  args: {
    corridorId: v.id("corridors"),
    targetLanguage: v.optional(v.string()),
  },
  handler: async (ctx, { corridorId, targetLanguage = "en" }) => {
    // Fetch ingested content for this corridor
    const content = await ctx.runQuery(api.ingestedContent.getByCorridor, {
      corridorId,
    });

    if (content.length === 0) {
      throw new Error("No research content found. Run research first.");
    }

    // Prepare content for synthesis
    const researchText = content
      .map((c) => `Source: ${c.url}\n${c.content}`)
      .join("\n\n---\n\n");

    // Get corridor details
    const corridor = await ctx.runQuery(api.corridors.getCorridor, {
      id: corridorId,
    });

    // Generate synthesis prompt
    const prompt = `
Analyze the following research about migrating from ${corridor?.origin} to ${corridor?.destination}.

Extract and structure protocol steps.

${targetLanguage !== "en" ? `Output all text in ${getLanguageName(targetLanguage)}.` : ""}

RESEARCH CONTENT:
${researchText}
`;

    // Execute synthesis agent
    const result = await protocolSynthesizer.generate(prompt);

    // Parse JSON from response
    const parsed = parseProtocolsFromResponse(result.text);

    // Build dependency graph and order
    const graph = buildDependencyGraph(parsed.protocols);
    const ordered = topologicalSort(graph);

    // Select best attributions and create final protocols
    const protocols = ordered.map((protocol, index) => ({
      category: protocol.category,
      title: protocol.title,
      description: protocol.description,
      priority: protocol.priority,
      order: index + 1,
      warnings: protocol.warnings,
      hacks: protocol.hacks,
      attribution: selectBestAttribution(protocol, content),
    }));

    // Save to database
    const ids = await ctx.runMutation(api.protocols.batchCreateProtocols, {
      corridorId,
      protocols,
    });

    return { protocolIds: ids, count: ids.length };
  },
});

function parseProtocolsFromResponse(text: string): { protocols: RawProtocol[] } {
  // Extract JSON from response (may be wrapped in markdown code blocks)
  const jsonMatch = text.match(/```json\n?([\s\S]*?)\n?```/) ||
                    text.match(/\{[\s\S]*"protocols"[\s\S]*\}/);

  if (!jsonMatch) {
    throw new Error("Failed to parse protocols from synthesis response");
  }

  const jsonStr = jsonMatch[1] || jsonMatch[0];
  return JSON.parse(jsonStr);
}

function getLanguageName(code: string): string {
  const names: Record<string, string> = {
    en: "English",
    yo: "Yoruba",
    hi: "Hindi",
    pt: "Portuguese",
    tl: "Tagalog",
  };
  return names[code] || "English";
}
```

### Dependency Graph
[Source: architecture.md#core-workflows]

```typescript
// lib/graph/dependencyGraph.ts
interface Protocol {
  title: string;
  dependsOn?: string[];
  [key: string]: any;
}

interface Graph {
  nodes: Map<string, Protocol>;
  edges: Map<string, string[]>; // title -> dependencies
}

export function buildDependencyGraph(protocols: Protocol[]): Graph {
  const nodes = new Map<string, Protocol>();
  const edges = new Map<string, string[]>();

  // Build nodes
  for (const protocol of protocols) {
    nodes.set(protocol.title, protocol);
    edges.set(protocol.title, protocol.dependsOn ?? []);
  }

  // Validate edges (remove references to non-existent nodes)
  for (const [title, deps] of edges) {
    const validDeps = deps.filter((dep) => nodes.has(dep));
    edges.set(title, validDeps);
  }

  return { nodes, edges };
}

export function topologicalSort(graph: Graph): Protocol[] {
  const { nodes, edges } = graph;
  const sorted: Protocol[] = [];
  const visited = new Set<string>();
  const visiting = new Set<string>();

  function visit(title: string) {
    if (visited.has(title)) return;
    if (visiting.has(title)) {
      // Circular dependency - break it by ignoring
      console.warn(`Circular dependency detected at: ${title}`);
      return;
    }

    visiting.add(title);

    // Visit dependencies first
    const deps = edges.get(title) ?? [];
    for (const dep of deps) {
      visit(dep);
    }

    visiting.delete(title);
    visited.add(title);

    const node = nodes.get(title);
    if (node) sorted.push(node);
  }

  // Visit all nodes
  for (const title of nodes.keys()) {
    visit(title);
  }

  return sorted;
}
```

### Attribution Scorer
[Source: architecture.md#data-models]

```typescript
// lib/scoring/attribution.ts
interface IngestedContent {
  url: string;
  metadata: {
    author?: string;
    publishedAt?: number;
  };
  scrapedAt: number;
}

interface RawProtocol {
  attribution?: {
    sourceUrl: string;
    authorName?: string;
    engagement?: number;
  };
}

export function selectBestAttribution(
  protocol: RawProtocol,
  allContent: IngestedContent[]
): { sourceUrl: string; authorName?: string; engagement?: number } | undefined {
  // If protocol already has attribution, validate and return
  if (protocol.attribution?.sourceUrl) {
    return protocol.attribution;
  }

  // Find matching content by URL fragments in description
  // This is a simplified matcher - could be enhanced with embeddings
  const matchingContent = allContent.find((c) =>
    protocol.attribution?.sourceUrl?.includes(c.url.split("#")[0])
  );

  if (matchingContent) {
    return {
      sourceUrl: matchingContent.url,
      authorName: matchingContent.metadata?.author,
      engagement: protocol.attribution?.engagement,
    };
  }

  return undefined;
}

export function scoreAttribution(attr: {
  engagement?: number;
  publishedAt?: number;
}): number {
  let score = 0;

  // Engagement score (normalized)
  if (attr.engagement) {
    score += Math.min(attr.engagement / 100, 10); // Cap at 10 points
  }

  // Recency score (within last year)
  if (attr.publishedAt) {
    const ageInDays = (Date.now() - attr.publishedAt) / (1000 * 60 * 60 * 24);
    if (ageInDays < 30) score += 5;
    else if (ageInDays < 90) score += 3;
    else if (ageInDays < 365) score += 1;
  }

  return score;
}
```

### Full Pipeline Action
[Source: architecture.md#core-workflows]

```typescript
// convex/ai/pipeline.ts
import { action } from "../_generated/server";
import { v } from "convex/values";
import { api } from "../_generated/api";

export const generateCorridorProtocols = action({
  args: {
    corridorId: v.id("corridors"),
    targetLanguage: v.optional(v.string()),
    forceRefresh: v.optional(v.boolean()),
  },
  handler: async (ctx, { corridorId, targetLanguage = "en", forceRefresh = false }) => {
    // Check if protocols already exist
    if (!forceRefresh) {
      const existing = await ctx.runQuery(api.protocols.getProtocols, {
        corridorId,
      });
      if (existing.length > 0) {
        return { protocolIds: existing.map((p) => p._id), cached: true };
      }
    }

    // Step 1: Research
    console.log("Starting corridor research...");
    const researchResult = await ctx.runAction(api.ai.research.researchCorridor, {
      corridorId,
    });
    console.log(`Research complete: ${researchResult.sources.length} sources`);

    // Step 2: Synthesize
    console.log("Synthesizing protocols...");
    const synthesisResult = await ctx.runAction(api.ai.synthesis.synthesizeProtocols, {
      corridorId,
      targetLanguage,
    });
    console.log(`Synthesis complete: ${synthesisResult.count} protocols`);

    return {
      protocolIds: synthesisResult.protocolIds,
      cached: false,
      sourcesUsed: researchResult.sources.length,
    };
  },
});
```

### File Structure
```
agents/
├── corridorResearcher.ts      # From Story 2.3
└── protocolSynthesizer.ts     # Synthesis agent

lib/
├── graph/
│   └── dependencyGraph.ts     # DAG + topological sort
└── scoring/
    └── attribution.ts         # Attribution scoring

convex/
└── ai/
    ├── research.ts            # From Story 2.3
    ├── synthesis.ts           # Synthesis action
    ├── embeddings.ts          # From Story 2.3
    └── pipeline.ts            # Full pipeline
```

### Dependencies from Previous Stories
- Story 2.1: Protocols table, batchCreateProtocols mutation
- Story 2.3: Research action, IngestedContent storage

---

## Testing

### Test Scenarios

1. **Synthesis Output**
   - [ ] Run synthesis on corridor with ingested content
   - [ ] Verify JSON output parses correctly
   - [ ] Check all required fields present

2. **Dependency Ordering**
   - [ ] Create test data with known dependencies
   - [ ] Verify topological sort produces correct order
   - [ ] Test circular dependency handling

3. **Protocol Storage**
   - [ ] Run full synthesis
   - [ ] Query protocols table
   - [ ] Verify order field reflects dependencies

4. **Multilingual Output**
   - [ ] Run synthesis with targetLanguage: "yo"
   - [ ] Verify protocol titles/descriptions in Yoruba
   - [ ] Test all 5 supported languages

5. **Full Pipeline**
   - [ ] Create new corridor
   - [ ] Run generateCorridorProtocols
   - [ ] Verify research → synthesis → storage chain

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-21 | 1.0 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*
