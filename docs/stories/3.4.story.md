# Story 3.4: Progress Tracking Checklist

## Status

**Complete**

---

## Story

**As a** user,
**I want** to mark steps as complete and track my progress,
**so that** I know what I've accomplished and what remains.

---

## Acceptance Criteria

1. Each protocol card has checkbox to mark complete
2. Completion state persisted to user profile in Convex
3. Progress bar shows overall completion percentage
4. Completed steps visually distinct (muted, checkmark)
5. Completion triggers subtle celebration animation
6. Progress survives logout/login (persisted)
7. Reset progress option available in settings

---

## Tasks / Subtasks

- [x] **Task 1: Create Progress Data Model** (AC: 2, 6)
  - [x] Add `userProgress` table to Convex schema
  - [x] Fields: userId, corridorId, protocolId, completedAt
  - [x] Create index on userId + corridorId
  - [x] Create `markComplete` mutation
  - [x] Create `markIncomplete` mutation
  - [x] Create `getProgress` query

- [x] **Task 2: Add Checkbox to ProtocolCard** (AC: 1, 4)
  - [x] Add completion checkbox to ProtocolCard header
  - [x] Style checkbox with RetroUI pattern
  - [x] Call `markComplete` mutation on check
  - [x] Call `markIncomplete` mutation on uncheck
  - [x] Optimistic update for immediate feedback

- [x] **Task 3: Create Progress Bar Component** (AC: 3)
  - [x] Create `components/protocol/ProgressBar.tsx`
  - [x] Calculate percentage from completed/total
  - [x] Style with RetroUI thick borders
  - [x] Animate fill on change
  - [x] Show percentage label

- [x] **Task 4: Style Completed Steps** (AC: 4)
  - [x] Reduce opacity for completed cards
  - [x] Show checkmark instead of step number
  - [x] Strikethrough title
  - [x] Move completed to bottom (optional)

- [x] **Task 5: Add Celebration Animation** (AC: 5)
  - [x] Create confetti animation on completion
  - [x] Use Framer Motion for animation
  - [x] Trigger only on new completions
  - [x] Brief animation (1-2 seconds)

- [x] **Task 6: Add Reset Progress Option** (AC: 7)
  - [x] Add "Reset Progress" to settings page
  - [x] Create `resetProgress` mutation
  - [ ] Confirmation dialog before reset (deferred to settings page story)
  - [x] Clear all progress for current corridor

- [x] **Task 7: Integrate with ProtocolList** (AC: 1-6)
  - [x] Fetch progress in ProtocolList
  - [x] Pass completion state to each ProtocolCard
  - [x] Add ProgressBar above card list
  - [x] Update progress on completion change

---

## Dev Notes

### Convex Schema Addition
[Source: architecture.md#data-models]

```typescript
// convex/schema.ts - Add userProgress table
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // ... existing tables ...

  userProgress: defineTable({
    userId: v.id("users"),
    corridorId: v.id("corridors"),
    protocolId: v.id("protocols"),
    completedAt: v.number(),
  })
    .index("by_user_corridor", ["userId", "corridorId"])
    .index("by_protocol", ["protocolId"]),
});
```

### Progress Mutations
```typescript
// convex/progress.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const markComplete = mutation({
  args: {
    protocolId: v.id("protocols"),
    corridorId: v.id("corridors"),
  },
  handler: async (ctx, { protocolId, corridorId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new Error("User not found");

    // Check if already completed
    const existing = await ctx.db
      .query("userProgress")
      .withIndex("by_user_corridor", (q) =>
        q.eq("userId", user._id).eq("corridorId", corridorId)
      )
      .filter((q) => q.eq(q.field("protocolId"), protocolId))
      .first();

    if (existing) return existing._id;

    return ctx.db.insert("userProgress", {
      userId: user._id,
      corridorId,
      protocolId,
      completedAt: Date.now(),
    });
  },
});

export const markIncomplete = mutation({
  args: {
    protocolId: v.id("protocols"),
  },
  handler: async (ctx, { protocolId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new Error("User not found");

    const progress = await ctx.db
      .query("userProgress")
      .withIndex("by_protocol", (q) => q.eq("protocolId", protocolId))
      .filter((q) => q.eq(q.field("userId"), user._id))
      .first();

    if (progress) {
      await ctx.db.delete(progress._id);
    }
  },
});

export const getProgress = query({
  args: {
    corridorId: v.id("corridors"),
  },
  handler: async (ctx, { corridorId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) return [];

    return ctx.db
      .query("userProgress")
      .withIndex("by_user_corridor", (q) =>
        q.eq("userId", user._id).eq("corridorId", corridorId)
      )
      .collect();
  },
});

export const resetProgress = mutation({
  args: {
    corridorId: v.id("corridors"),
  },
  handler: async (ctx, { corridorId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new Error("User not found");

    const progressItems = await ctx.db
      .query("userProgress")
      .withIndex("by_user_corridor", (q) =>
        q.eq("userId", user._id).eq("corridorId", corridorId)
      )
      .collect();

    for (const item of progressItems) {
      await ctx.db.delete(item._id);
    }

    return { deleted: progressItems.length };
  },
});
```

### Progress Bar Component
```typescript
// components/protocol/ProgressBar.tsx
"use client";

import { useTranslations } from "next-intl";
import { motion } from "framer-motion";

interface ProgressBarProps {
  completed: number;
  total: number;
}

export function ProgressBar({ completed, total }: ProgressBarProps) {
  const t = useTranslations("protocols");
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

  return (
    <div className="border-4 border-black bg-white p-4 shadow-[4px_4px_0_0_#000]">
      <div className="flex items-center justify-between mb-2">
        <span className="font-bold">{t("progress")}</span>
        <span className="text-sm text-gray-600">
          {completed} / {total} {t("completed")}
        </span>
      </div>

      <div className="h-6 bg-gray-200 border-2 border-black overflow-hidden">
        <motion.div
          className="h-full bg-green-500"
          initial={{ width: 0 }}
          animate={{ width: `${percentage}%` }}
          transition={{ duration: 0.5, ease: "easeOut" }}
        />
      </div>

      <div className="text-center mt-2 font-bold text-lg">
        {percentage}%
      </div>
    </div>
  );
}
```

### Completion Checkbox in ProtocolCard
```typescript
// Update components/protocol/ProtocolCard.tsx

interface ProtocolCardProps {
  protocol: Doc<"protocols">;
  isCurrent: boolean;
  isCompleted: boolean;  // NEW
  onComplete: (protocolId: Id<"protocols">) => void;  // NEW
  onUncomplete: (protocolId: Id<"protocols">) => void;  // NEW
}

export function ProtocolCard({
  protocol,
  isCurrent,
  isCompleted,
  onComplete,
  onUncomplete,
}: ProtocolCardProps) {
  const [showConfetti, setShowConfetti] = useState(false);

  const handleCheckChange = (checked: boolean) => {
    if (checked) {
      onComplete(protocol._id);
      setShowConfetti(true);
      setTimeout(() => setShowConfetti(false), 2000);
    } else {
      onUncomplete(protocol._id);
    }
  };

  return (
    <div className={`relative ${isCompleted ? "opacity-60" : ""}`}>
      {showConfetti && <Confetti />}

      {/* Header with Checkbox */}
      <div className="p-4 flex items-start gap-4">
        {/* Completion Checkbox */}
        <button
          onClick={() => handleCheckChange(!isCompleted)}
          className={`
            w-10 h-10 flex items-center justify-center
            border-4 border-black font-bold text-lg
            transition-colors
            ${isCompleted ? "bg-green-500 text-white" : "bg-white hover:bg-gray-100"}
          `}
        >
          {isCompleted ? "✓" : protocol.order}
        </button>

        {/* Rest of card content... */}
      </div>
    </div>
  );
}
```

### Confetti Animation
```typescript
// components/protocol/Confetti.tsx
"use client";

import { motion } from "framer-motion";

export function Confetti() {
  const colors = ["#10b981", "#3b82f6", "#f59e0b", "#ef4444", "#8b5cf6"];
  const pieces = Array.from({ length: 50 }, (_, i) => ({
    id: i,
    color: colors[i % colors.length],
    x: Math.random() * 100 - 50,
    y: Math.random() * -100 - 50,
    rotation: Math.random() * 360,
  }));

  return (
    <div className="absolute inset-0 overflow-hidden pointer-events-none z-50">
      {pieces.map((piece) => (
        <motion.div
          key={piece.id}
          className="absolute w-2 h-2"
          style={{
            backgroundColor: piece.color,
            left: "50%",
            top: "50%",
          }}
          initial={{
            x: 0,
            y: 0,
            rotate: 0,
            opacity: 1,
          }}
          animate={{
            x: piece.x,
            y: piece.y,
            rotate: piece.rotation,
            opacity: 0,
          }}
          transition={{
            duration: 1.5,
            ease: "easeOut",
          }}
        />
      ))}
    </div>
  );
}
```

### Updated ProtocolList with Progress
```typescript
// Update components/protocol/ProtocolList.tsx
"use client";

import { useMutation, useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { ProtocolCard } from "./ProtocolCard";
import { ProgressBar } from "./ProgressBar";

export function ProtocolList({ protocols, corridorId }: ProtocolListProps) {
  const progress = useQuery(api.progress.getProgress, { corridorId });
  const markComplete = useMutation(api.progress.markComplete);
  const markIncomplete = useMutation(api.progress.markIncomplete);

  const completedIds = new Set(progress?.map((p) => p.protocolId) ?? []);
  const completedCount = completedIds.size;

  // Sort: incomplete first, then completed
  const sorted = [...protocols].sort((a, b) => {
    const aComplete = completedIds.has(a._id);
    const bComplete = completedIds.has(b._id);
    if (aComplete !== bComplete) return aComplete ? 1 : -1;
    return a.order - b.order;
  });

  const handleComplete = async (protocolId: Id<"protocols">) => {
    await markComplete({ protocolId, corridorId });
  };

  const handleUncomplete = async (protocolId: Id<"protocols">) => {
    await markIncomplete({ protocolId });
  };

  return (
    <div className="space-y-6">
      {/* Progress Bar */}
      <ProgressBar completed={completedCount} total={protocols.length} />

      {/* Protocol Cards */}
      <div className="space-y-4">
        {sorted.map((protocol) => (
          <ProtocolCard
            key={protocol._id}
            protocol={protocol}
            isCurrent={!completedIds.has(protocol._id) && protocol.order === sorted.find((p) => !completedIds.has(p._id))?.order}
            isCompleted={completedIds.has(protocol._id)}
            onComplete={handleComplete}
            onUncomplete={handleUncomplete}
          />
        ))}
      </div>
    </div>
  );
}
```

### Translation Keys
```json
// messages/en.json - Add progress keys
{
  "protocols": {
    "progress": "Your Progress",
    "resetProgress": "Reset Progress",
    "resetConfirm": "This will reset all your progress. Are you sure?",
    "resetSuccess": "Progress reset successfully"
  }
}
```

### File Structure
```
convex/
└── progress.ts            # Progress mutations and queries

components/
└── protocol/
    ├── ProtocolCard.tsx   # Updated with checkbox
    ├── ProtocolList.tsx   # Updated with progress
    ├── ProgressBar.tsx    # New progress bar
    └── Confetti.tsx       # New celebration animation
```

### Dependencies from Previous Stories
- Story 3.2: ProtocolCard component (to update)
- Story 3.2: ProtocolList component (to update)
- Story 2.1: Protocols table schema

---

## Testing

### Test Scenarios

1. **Mark Complete**
   - [ ] Click checkbox marks step complete
   - [ ] Checkmark appears immediately (optimistic)
   - [ ] Progress bar updates
   - [ ] Confetti animation plays

2. **Mark Incomplete**
   - [ ] Click checked box removes completion
   - [ ] Step returns to normal state
   - [ ] Progress bar updates

3. **Persistence**
   - [ ] Refresh page - progress retained
   - [ ] Logout/login - progress retained
   - [ ] Different device - progress synced

4. **Progress Bar**
   - [ ] Shows correct percentage
   - [ ] Animates on change
   - [ ] Shows X/Y completed count

5. **Reset Progress**
   - [ ] Confirmation dialog appears
   - [ ] All progress cleared on confirm
   - [ ] Progress bar resets to 0%

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-21 | 1.0 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*
