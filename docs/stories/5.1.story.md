# Story 5.1: Audio Briefing Generation

## Status

**Completed**

---

## Story

**As a** system,
**I want** to generate personalized audio briefing scripts,
**so that** users can listen to their migration updates hands-free.

---

## Acceptance Criteria

1. Briefing script generated based on user's corridor, stage, and progress
2. Script written by Claude in user's selected language
3. Script follows NPR-style format: greeting, key updates, tips, next actions
4. Script length appropriate for briefing type (daily: 2-3 min, weekly: 5-7 min)
5. Script includes mention of attributed sources naturally
6. Scripts cached in Convex with user reference
7. Script regenerated when user profile or progress changes significantly

---

## Tasks / Subtasks

- [x] **Task 1: Create Briefing Script Agent** (AC: 1, 2, 3)
  - [x] Create `agents/briefingWriter.ts`
  - [x] Configure Gemini 3 Flash Preview model (adapted from Claude)
  - [x] Write NPR-style system prompt
  - [x] Include language instructions

- [x] **Task 2: Create Script Generation Action** (AC: 1, 4, 5)
  - [x] Create `convex/ai/briefings.ts`
  - [x] Implement `generateBriefingScript` action
  - [x] Gather user context (corridor, stage, progress)
  - [x] Control script length by briefing type

- [x] **Task 3: Add Briefings Schema** (AC: 6)
  - [x] Add `briefings` table to schema
  - [x] Fields: userId, corridorId, type, script, createdAt
  - [x] Index by user and corridor

- [x] **Task 4: Implement Script Caching** (AC: 6, 7)
  - [x] Save generated scripts to Convex
  - [x] Check for existing script before generating
  - [x] Invalidate on progress change

- [x] **Task 5: Create Briefing Types** (AC: 4)
  - [x] Daily briefing (2-3 min, ~400 words)
  - [x] Weekly briefing (5-7 min, ~1000 words)
  - [x] Progress update (1-2 min, ~200 words)

- [x] **Task 6: Add Source Attribution** (AC: 5)
  - [x] Include sources naturally in script
  - [x] "According to expats who've done this..."
  - [x] Reference community knowledge

- [x] **Task 7: Detect Significant Changes** (AC: 7)
  - [x] Track last briefing generation time
  - [x] Compare current progress to last briefing
  - [x] Trigger regeneration on significant delta

---

## Dev Notes

### Briefing Writer Agent
[Source: architecture.md#mastra-agent-integration]

```typescript
// agents/briefingWriter.ts
import { Agent } from "@mastra/core";

export const briefingWriter = new Agent({
  name: "BriefingWriter",
  model: "claude-sonnet-4-20250514",
  instructions: `You are a briefing script writer for TRIBE, creating audio content for migrants.

Your role is to write engaging, NPR-style audio briefings that help users prepare for migration.

SCRIPT STRUCTURE:
1. Warm greeting with personalization
2. Progress celebration (what they've accomplished)
3. Key updates relevant to their stage
4. Practical tips from the community
5. Next action items (clear, actionable)
6. Encouraging sign-off

STYLE GUIDELINES:
- Conversational, warm, encouraging tone
- Use natural spoken language (not written)
- Include pauses with "..." for breathing room
- Use "you" and "your" to make it personal
- Reference sources naturally ("Expats recommend...")
- Avoid jargon, explain terms simply

LANGUAGE:
- Write in the user's specified language
- Use appropriate cultural references
- Match formality to language norms

LENGTH TARGETS:
- Daily: 400-500 words (~2-3 minutes)
- Weekly: 900-1100 words (~5-7 minutes)
- Progress update: 150-250 words (~1-2 minutes)

Example opening:
"Good morning! It's your TRIBE briefing, and I've got some exciting updates for your journey to Germany...

First, congratulations on completing the language school registration! That's a big step forward..."
`,
  tools: [],
});
```

### Briefings Schema
```typescript
// convex/schema.ts - Add briefings table
briefings: defineTable({
  userId: v.id("users"),
  corridorId: v.id("corridors"),
  type: v.union(
    v.literal("daily"),
    v.literal("weekly"),
    v.literal("progress")
  ),
  script: v.string(),
  wordCount: v.number(),
  language: v.string(),
  context: v.object({
    stage: v.string(),
    completedSteps: v.number(),
    totalSteps: v.number(),
    recentCompletions: v.array(v.string()),
  }),
  createdAt: v.number(),
  expiresAt: v.optional(v.number()),
})
  .index("by_user", ["userId"])
  .index("by_user_corridor", ["userId", "corridorId"])
  .index("by_user_type", ["userId", "type"]),
```

### Script Generation Action
```typescript
// convex/ai/briefings.ts
import { action, query, mutation } from "../_generated/server";
import { v } from "convex/values";
import { api } from "../_generated/api";
import { briefingWriter } from "../../agents/briefingWriter";

type BriefingType = "daily" | "weekly" | "progress";

const WORD_TARGETS: Record<BriefingType, { min: number; max: number }> = {
  daily: { min: 400, max: 500 },
  weekly: { min: 900, max: 1100 },
  progress: { min: 150, max: 250 },
};

export const generateBriefingScript = action({
  args: {
    corridorId: v.id("corridors"),
    type: v.union(v.literal("daily"), v.literal("weekly"), v.literal("progress")),
    forceRegenerate: v.optional(v.boolean()),
  },
  handler: async (ctx, { corridorId, type, forceRegenerate = false }) => {
    const startTime = Date.now();

    // Get user profile
    const profile = await ctx.runQuery(api.users.getProfile);
    if (!profile) throw new Error("User not found");

    // Check for cached briefing
    if (!forceRegenerate) {
      const cached = await ctx.runQuery(api.ai.briefings.getLatestBriefing, {
        corridorId,
        type,
      });

      // Return cached if recent enough
      const maxAge = type === "daily" ? 12 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000;
      if (cached && Date.now() - cached.createdAt < maxAge) {
        return { script: cached.script, cached: true };
      }
    }

    // Gather context
    const corridor = await ctx.runQuery(api.corridors.getCorridor, {
      id: corridorId,
    });

    const protocols = await ctx.runQuery(api.protocols.getProtocols, {
      corridorId,
    });

    const progress = await ctx.runQuery(api.progress.getProgress, {
      corridorId,
    });

    // Calculate progress stats
    const completedIds = new Set(progress.map((p) => p.protocolId));
    const completedSteps = completedIds.size;
    const totalSteps = protocols.length;
    const recentCompletions = progress
      .filter((p) => Date.now() - p.completedAt < 7 * 24 * 60 * 60 * 1000)
      .map((p) => protocols.find((pr) => pr._id === p.protocolId)?.title)
      .filter(Boolean) as string[];

    // Get next steps (incomplete, by order)
    const nextSteps = protocols
      .filter((p) => !completedIds.has(p._id))
      .sort((a, b) => a.order - b.order)
      .slice(0, 3)
      .map((p) => p.title);

    // Build prompt
    const prompt = buildBriefingPrompt({
      type,
      language: profile.language ?? "en",
      corridor: corridor!,
      stage: corridor?.stage ?? "planning",
      completedSteps,
      totalSteps,
      recentCompletions,
      nextSteps,
      wordTarget: WORD_TARGETS[type],
    });

    // Generate script
    const result = await briefingWriter.generate(prompt);
    const script = result.text;
    const wordCount = script.split(/\s+/).length;

    // Save to database
    await ctx.runMutation(api.ai.briefings.saveBriefing, {
      corridorId,
      type,
      script,
      wordCount,
      language: profile.language ?? "en",
      context: {
        stage: corridor?.stage ?? "planning",
        completedSteps,
        totalSteps,
        recentCompletions,
      },
    });

    console.log(`Briefing generated in ${Date.now() - startTime}ms, ${wordCount} words`);

    return { script, cached: false, wordCount };
  },
});

function buildBriefingPrompt(params: {
  type: BriefingType;
  language: string;
  corridor: { origin: string; destination: string };
  stage: string;
  completedSteps: number;
  totalSteps: number;
  recentCompletions: string[];
  nextSteps: string[];
  wordTarget: { min: number; max: number };
}): string {
  const languageNames: Record<string, string> = {
    en: "English",
    yo: "Yoruba",
    hi: "Hindi",
    pt: "Portuguese",
    tl: "Tagalog",
  };

  return `Generate a ${params.type} audio briefing script.

WRITE IN: ${languageNames[params.language] ?? "English"}

USER CONTEXT:
- Journey: ${params.corridor.origin} → ${params.corridor.destination}
- Current stage: ${params.stage}
- Progress: ${params.completedSteps} of ${params.totalSteps} steps completed

RECENT ACCOMPLISHMENTS:
${params.recentCompletions.length > 0 ? params.recentCompletions.map((c) => `- ${c}`).join("\n") : "- No recent completions"}

NEXT STEPS TO MENTION:
${params.nextSteps.map((s) => `- ${s}`).join("\n")}

TARGET LENGTH: ${params.wordTarget.min}-${params.wordTarget.max} words

Remember to:
- Start with a warm, personalized greeting
- Celebrate recent progress
- Provide encouragement
- End with clear next action`;
}
```

### Briefing Queries and Mutations
```typescript
// convex/ai/briefings.ts (continued)

export const getLatestBriefing = query({
  args: {
    corridorId: v.id("corridors"),
    type: v.union(v.literal("daily"), v.literal("weekly"), v.literal("progress")),
  },
  handler: async (ctx, { corridorId, type }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) return null;

    return ctx.db
      .query("briefings")
      .withIndex("by_user_corridor", (q) =>
        q.eq("userId", user._id).eq("corridorId", corridorId)
      )
      .filter((q) => q.eq(q.field("type"), type))
      .order("desc")
      .first();
  },
});

export const saveBriefing = mutation({
  args: {
    corridorId: v.id("corridors"),
    type: v.union(v.literal("daily"), v.literal("weekly"), v.literal("progress")),
    script: v.string(),
    wordCount: v.number(),
    language: v.string(),
    context: v.object({
      stage: v.string(),
      completedSteps: v.number(),
      totalSteps: v.number(),
      recentCompletions: v.array(v.string()),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new Error("User not found");

    return ctx.db.insert("briefings", {
      userId: user._id,
      ...args,
      createdAt: Date.now(),
    });
  },
});

export const getBriefingHistory = query({
  args: {
    corridorId: v.id("corridors"),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, { corridorId, limit = 10 }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerk_id", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) return [];

    return ctx.db
      .query("briefings")
      .withIndex("by_user_corridor", (q) =>
        q.eq("userId", user._id).eq("corridorId", corridorId)
      )
      .order("desc")
      .take(limit);
  },
});
```

### File Structure
```
agents/
└── briefingWriter.ts     # Briefing script agent

convex/
└── ai/
    └── briefings.ts      # Briefing generation action
```

### Dependencies from Previous Stories
- Story 1.5: User profile with language preference
- Story 3.4: Progress tracking data

---

## Testing

### Test Scenarios

1. **Script Generation**
   - [ ] Script generated for daily type
   - [ ] Script generated for weekly type
   - [ ] Script in user's language

2. **Script Content**
   - [ ] Contains greeting
   - [ ] References user's corridor
   - [ ] Mentions recent progress
   - [ ] Includes next steps

3. **Script Length**
   - [ ] Daily: 400-500 words
   - [ ] Weekly: 900-1100 words
   - [ ] Progress: 150-250 words

4. **Caching**
   - [ ] Script saved to Convex
   - [ ] Cached script returned if recent
   - [ ] Force regenerate bypasses cache

5. **Context Awareness**
   - [ ] Correct corridor mentioned
   - [ ] Current stage referenced
   - [ ] Progress stats accurate

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-21 | 1.0 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

**Completed:** 2025-12-23

### Files Created
- `agents/briefingWriter.ts` - Briefing script agent with NPR-style instructions
- `convex/ai/briefings.ts` - Script generation action with caching
- `convex/briefingsQueries.ts` - Internal queries and public queries for briefings

### Files Modified
- `convex/schema.ts` - Added briefings table with indexes
- `convex/ai/searchActions.ts` - Fixed type annotations for content map

### Implementation Notes
- Adapted agent to use Gemini 3 Flash Preview instead of Claude (project uses Google AI)
- Uses Mastra Agent pattern consistent with existing corridorResearcher agent
- Script caching with time-based expiry (12h daily, 24h weekly, 1h progress)
- Progress change detection triggers regeneration on 2+ new completions
- Token usage logged to monitoring infrastructure
- Supports all 9 languages: en, yo, hi, pt, tl, ko, de, fr, es

### Key Functions
- `generateBriefingScript` - Main action to generate or return cached briefing
- `buildBriefingPrompt` - Constructs prompt with user context
- `shouldRegenerateBriefing` - Query to check if regeneration needed
- `getLatestBriefing` / `getBriefingHistory` - Public queries for frontend

### Build Status
- TypeScript: ✅ Passed
- Convex deploy: ✅ Deployed

---

## QA Results
*To be filled by QA Agent*
