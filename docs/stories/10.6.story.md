# Story 10.6: Shared State Synchronization

## Status

**Completed**

---

## Story

**As a** user,
**I want** my corridor context automatically available to the AI agent,
**so that** responses are personalized without me repeating information.

---

## Acceptance Criteria

1. CopilotProvider passes corridor state via `properties` prop: userId, corridorId, origin, destination, stage, language
2. ADK agent receives state on every request and includes in system prompt context
3. Agent responses reference user's corridor: "For your Nigeria → Canada journey..."
4. State updates from frontend (e.g., stage change) reflected in next agent interaction
5. Language preference respected: agent responds in user's selected language
6. Agent can access user's saved documents and todos for context-aware responses
7. Shared state sync verified with real-time state changes

---

## Tasks / Subtasks

- [x] **Task 1: Configure CopilotKit Properties** (AC: 1)
  - [x] Update CopilotKit provider with properties prop
  - [x] Pass corridor data: corridorId, origin, destination, stage
  - [x] Pass user data: userId, language preference
  - [x] Ensure properties update when corridor changes

- [x] **Task 2: Create State Provider Hook** (AC: 1, 4)
  - [x] Create `useChatContext` hook (already in CopilotProvider.tsx)
  - [x] Fetch current corridor from Convex
  - [x] Fetch user profile for language preference
  - [x] Memoize to prevent unnecessary re-renders
  - [x] Update on corridor/user changes

- [x] **Task 3: Update ADK Agent to Use State** (AC: 2, 3, 5)
  - [x] Receive shared state in agent request
  - [x] Inject state into system prompt dynamically
  - [x] Format context: "User is migrating from {origin} to {destination}..."
  - [x] Include language instruction: "Respond in {language}"
  - [x] Reference corridor in responses naturally

- [x] **Task 4: Add Context Data Access** (AC: 6)
  - [x] Create Convex HTTP endpoint: GET /api/user/context
  - [x] Return user's recent todos (top 5)
  - [x] Return corridor progress (protocols completed)
  - [x] ADK agent can fetch this on-demand

- [x] **Task 5: Create Context Fetch Tool** (AC: 6)
  - [x] Create `get_user_context` tool in ADK agent
  - [x] Tool fetches user's todos, progress
  - [x] Agent uses this for personalized responses
  - [x] Tool is internal (not shown in UI)

- [x] **Task 6: Test Real-Time Sync** (AC: 4, 7)
  - [x] Build passes successfully
  - [x] Agent can receive context and personalize responses
  - [x] State flows from CopilotKit → ADK agent

---

## Technical Implementation Notes

### CopilotKit Properties Configuration
```typescript
// apps/web/app/(dashboard)/chat/ChatProvider.tsx
"use client";

import { CopilotKit } from "@copilotkit/react-core";
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useChatContext } from "@/hooks/useChatContext";

export function ChatProvider({ children }: { children: React.ReactNode }) {
  const { corridor, user, isLoading } = useChatContext();

  if (isLoading) {
    return <div>Loading chat context...</div>;
  }

  const properties = {
    // User context
    userId: user?._id,
    language: user?.language || "en",

    // Corridor context
    corridorId: corridor?._id,
    origin: corridor?.origin,
    destination: corridor?.destination,
    stage: corridor?.stage,

    // Metadata
    timestamp: Date.now(),
  };

  return (
    <CopilotKit
      runtimeUrl="/api/copilotkit"
      agent="tribe_agent"
      properties={properties}
    >
      {children}
    </CopilotKit>
  );
}
```

### Chat Context Hook
```typescript
// hooks/useChatContext.ts
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useMemo } from "react";

export function useChatContext() {
  const user = useQuery(api.users.getCurrentUser);
  const corridors = useQuery(api.corridors.getCorridors);

  // Get active corridor (most recently updated)
  const corridor = useMemo(() => {
    if (!corridors || corridors.length === 0) return null;
    return corridors.sort((a, b) => b.updatedAt - a.updatedAt)[0];
  }, [corridors]);

  return {
    user,
    corridor,
    isLoading: user === undefined || corridors === undefined,
  };
}
```

### ADK Agent State Handling
```python
# agents/tribe_agent/agent.py
from google.adk import Agent

def build_system_prompt(state: dict) -> str:
    """Build dynamic system prompt with user context."""
    base_prompt = """You are TRIBE, a culturally-aware migration intelligence assistant."""

    context_parts = []

    # Corridor context
    if state.get("origin") and state.get("destination"):
        context_parts.append(
            f"The user is planning to migrate from {state['origin']} to {state['destination']}."
        )

    # Stage context
    stage_descriptions = {
        "dreaming": "They are in the early dreaming phase, exploring possibilities.",
        "planning": "They are actively planning their migration journey.",
        "preparing": "They are preparing documents and logistics.",
        "relocating": "They are in the process of relocating.",
        "settling": "They have arrived and are settling into their new home."
    }
    if state.get("stage"):
        context_parts.append(stage_descriptions.get(state["stage"], ""))

    # Language instruction
    language_names = {
        "en": "English",
        "yo": "Yoruba",
        "hi": "Hindi",
        "pt": "Portuguese",
        "tl": "Tagalog"
    }
    lang = state.get("language", "en")
    context_parts.append(
        f"Respond in {language_names.get(lang, 'English')} unless the user requests otherwise."
    )

    if context_parts:
        return base_prompt + "\n\nCURRENT CONTEXT:\n" + "\n".join(context_parts)

    return base_prompt

# Agent receives state via AG-UI protocol
tribe_agent = Agent(
    name="TribeAgent",
    model="gemini-2.5-flash",
    description="TRIBE migration intelligence assistant",
    instruction=build_system_prompt,  # Dynamic prompt function
    tools=[search_housing_resources, search_live_data, search_visa_options, get_user_context]
)
```

### User Context Tool
```python
# agents/tribe_agent/tools/context.py
import os
import httpx
from google.adk.tools import FunctionTool

CONVEX_SITE_URL = os.environ.get("CONVEX_SITE_URL", "")

@FunctionTool
async def get_user_context(user_id: str, corridor_id: str) -> dict:
    """
    Fetch user's current context including todos, saved documents, and progress.
    Use this to provide personalized, context-aware responses.

    Args:
        user_id: The user's ID
        corridor_id: The active corridor ID

    Returns:
        dict with todos, documents, and corridor progress
    """
    async with httpx.AsyncClient(timeout=10.0) as client:
        try:
            response = await client.get(
                f"{CONVEX_SITE_URL}/api/user/context",
                params={"userId": user_id, "corridorId": corridor_id}
            )
            return response.json()
        except Exception as e:
            return {"error": f"Could not fetch context: {str(e)}"}
```

### Convex Context Endpoint
```typescript
// convex/http.ts

http.route({
  path: "/api/user/context",
  method: "GET",
  handler: httpAction(async (ctx, request) => {
    const url = new URL(request.url);
    const corridorId = url.searchParams.get("corridorId");

    if (!corridorId) {
      return new Response(JSON.stringify({ error: "corridorId required" }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }

    const [todos, documents, protocols] = await Promise.all([
      ctx.runQuery(api.tasks.getTasks, { corridorId: corridorId as Id<"corridors"> }),
      ctx.runQuery(api.documents.getDocuments, { corridorId: corridorId as Id<"corridors"> }),
      ctx.runQuery(api.protocols.getProtocols, { corridorId: corridorId as Id<"corridors"> })
    ]);

    const completedProtocols = protocols?.filter(p => p.status === "completed").length || 0;
    const totalProtocols = protocols?.length || 0;

    return new Response(JSON.stringify({
      todos: todos?.slice(0, 5).map(t => ({ title: t.title, column: t.column })) || [],
      documents: documents?.slice(0, 5).map(d => ({ title: d.title, type: d.type })) || [],
      progress: {
        completed: completedProtocols,
        total: totalProtocols,
        percentage: totalProtocols > 0 ? Math.round((completedProtocols / totalProtocols) * 100) : 0
      }
    }), {
      headers: { "Content-Type": "application/json" }
    });
  }),
});
```

---

## Dependencies

- **Upstream**: Story 10.1 (ADK Agent), Story 10.2 (CopilotRuntime)
- **Convex**: users.getCurrentUser, corridors.getCorridors, tasks.getTasks
- **CopilotKit**: properties prop support

---

## Testing Strategy

### Test Cases

1. **Initial State Pass**:
   - Properties sent with first message
   - Agent acknowledges corridor context

2. **Language Preference**:
   - Set language to Yoruba
   - Agent responds in Yoruba
   - Switch to Portuguese
   - Agent switches language

3. **Corridor Context**:
   - Ask "what's my destination?"
   - Agent knows destination without being told
   - Ask "what stage am I in?"
   - Agent knows current stage

4. **Context Updates**:
   - Change stage in UI
   - Ask agent about stage
   - Agent reflects new stage

5. **User Context Fetch**:
   - Agent fetches todos when relevant
   - Agent references saved documents
   - Agent mentions progress percentage

6. **Edge Cases**:
   - No corridor yet → Agent handles gracefully
   - Multiple corridors → Uses most recent
   - Missing user → Default to English
