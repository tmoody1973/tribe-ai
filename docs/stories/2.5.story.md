# Story 2.5: Protocol Caching & Freshness

## Status

**Draft**

---

## Story

**As a** system,
**I want** to cache protocols and refresh stale data,
**so that** users get fast responses while data stays current.

---

## Acceptance Criteria

1. Protocol retrieval checks cache first before triggering research
2. Protocols older than 30 days flagged as stale
3. Stale protocols trigger background refresh while returning cached data
4. Manual refresh available via admin function (for testing)
5. Protocol status tracked: fresh, stale, refreshing, error
6. Cache hit/miss metrics logged for monitoring

---

## Tasks / Subtasks

- [ ] **Task 1: Add Freshness Fields to Corridors** (AC: 2, 5)
  - [ ] Update `convex/schema.ts` corridors table:
    - Add `lastResearchedAt: v.optional(v.number())`
    - Add `researchStatus: v.optional(v.string())` // fresh, stale, refreshing, error
    - Add `protocolCount: v.optional(v.number())`
  - [ ] Run schema migration

- [ ] **Task 2: Create Freshness Check Query** (AC: 1, 2)
  - [ ] Create `convex/corridors.ts` → `checkFreshness` query
  - [ ] Calculate staleness: `Date.now() - lastResearchedAt > 30 days`
  - [ ] Return: `{ isFresh, isStale, lastResearched, status }`
  - [ ] Handle corridors with no research yet

- [ ] **Task 3: Create Cache-First Protocol Retrieval** (AC: 1)
  - [ ] Create `convex/protocols.ts` → `getProtocolsWithFreshness` query
  - [ ] Check corridor freshness
  - [ ] Return protocols with freshness metadata
  - [ ] Include `stale: boolean` flag in response

- [ ] **Task 4: Implement Background Refresh** (AC: 3)
  - [ ] Create `convex/ai/refresh.ts` → `refreshCorridorInBackground` action
  - [ ] Set status to "refreshing" before starting
  - [ ] Run research and synthesis pipeline
  - [ ] Update status to "fresh" on success, "error" on failure
  - [ ] Use Convex scheduler for background execution

- [ ] **Task 5: Create Stale Protocol Handler** (AC: 3)
  - [ ] Update `getProtocolsWithFreshness` to trigger refresh
  - [ ] Return cached data immediately
  - [ ] Schedule background refresh via scheduler
  - [ ] Don't block on refresh completion

- [ ] **Task 6: Create Admin Refresh Function** (AC: 4)
  - [ ] Create `convex/admin.ts` → `forceRefreshCorridor` mutation
  - [ ] Accept corridorId parameter
  - [ ] Bypass freshness check
  - [ ] Trigger immediate research + synthesis
  - [ ] Useful for testing and manual intervention

- [ ] **Task 7: Implement Cache Metrics Logging** (AC: 6)
  - [ ] Create `convex/metrics.ts`
  - [ ] Log: cache hits, cache misses, refresh triggers
  - [ ] Store in metrics table for dashboard
  - [ ] Add timestamp and corridorId context

- [ ] **Task 8: Create Scheduled Cleanup Job** (AC: 2)
  - [ ] Create `convex/crons.ts` with scheduled function
  - [ ] Run daily: find stale corridors
  - [ ] Pre-emptively refresh popular corridors
  - [ ] Clean up expired ingested content

---

## Dev Notes

### Updated Corridors Schema
[Source: architecture.md#database-schema]

```typescript
// convex/schema.ts - Update corridors table
corridors: defineTable({
  userId: v.id("users"),
  origin: v.string(),
  destination: v.string(),
  stage: v.union(
    v.literal("dreaming"),
    v.literal("planning"),
    v.literal("preparing"),
    v.literal("relocating"),
    v.literal("settling")
  ),
  // Freshness tracking (NEW)
  lastResearchedAt: v.optional(v.number()),
  researchStatus: v.optional(v.union(
    v.literal("fresh"),
    v.literal("stale"),
    v.literal("refreshing"),
    v.literal("error")
  )),
  protocolCount: v.optional(v.number()),
  errorMessage: v.optional(v.string()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_corridor", ["origin", "destination"])
  .index("by_status", ["researchStatus"]),
```

### Freshness Constants
```typescript
// lib/constants/freshness.ts
export const FRESHNESS_THRESHOLD_MS = 30 * 24 * 60 * 60 * 1000; // 30 days
export const CONTENT_EXPIRY_MS = 30 * 24 * 60 * 60 * 1000; // 30 days

export function isFresh(lastResearchedAt: number | undefined): boolean {
  if (!lastResearchedAt) return false;
  return Date.now() - lastResearchedAt < FRESHNESS_THRESHOLD_MS;
}

export function isStale(lastResearchedAt: number | undefined): boolean {
  if (!lastResearchedAt) return true;
  return Date.now() - lastResearchedAt >= FRESHNESS_THRESHOLD_MS;
}
```

### Freshness Check Query
```typescript
// convex/corridors.ts - Add freshness check
export const checkFreshness = query({
  args: { corridorId: v.id("corridors") },
  handler: async (ctx, { corridorId }) => {
    const corridor = await ctx.db.get(corridorId);
    if (!corridor) return null;

    const lastResearchedAt = corridor.lastResearchedAt;
    const thresholdMs = 30 * 24 * 60 * 60 * 1000; // 30 days

    const isFresh = lastResearchedAt
      ? Date.now() - lastResearchedAt < thresholdMs
      : false;

    return {
      corridorId,
      isFresh,
      isStale: !isFresh,
      lastResearchedAt,
      status: corridor.researchStatus ?? (isFresh ? "fresh" : "stale"),
      protocolCount: corridor.protocolCount ?? 0,
    };
  },
});
```

### Cache-First Protocol Retrieval
[Source: architecture.md#core-workflows]

```typescript
// convex/protocols.ts - Add cache-first retrieval
export const getProtocolsWithFreshness = query({
  args: { corridorId: v.id("corridors") },
  handler: async (ctx, { corridorId }) => {
    const corridor = await ctx.db.get(corridorId);
    if (!corridor) return null;

    const protocols = await ctx.db
      .query("protocols")
      .withIndex("by_corridor", (q) => q.eq("corridorId", corridorId))
      .collect();

    const lastResearchedAt = corridor.lastResearchedAt;
    const thresholdMs = 30 * 24 * 60 * 60 * 1000;
    const isStale = !lastResearchedAt || Date.now() - lastResearchedAt >= thresholdMs;

    return {
      protocols: protocols.sort((a, b) => a.order - b.order),
      freshness: {
        isStale,
        lastResearchedAt,
        status: corridor.researchStatus ?? "unknown",
        refreshing: corridor.researchStatus === "refreshing",
      },
    };
  },
});
```

### Background Refresh Action
[Source: architecture.md#backend-architecture]

```typescript
// convex/ai/refresh.ts
import { action, internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { api, internal } from "../_generated/api";

export const refreshCorridorInBackground = action({
  args: { corridorId: v.id("corridors") },
  handler: async (ctx, { corridorId }) => {
    // Set status to refreshing
    await ctx.runMutation(internal.corridors.updateResearchStatus, {
      corridorId,
      status: "refreshing",
    });

    try {
      // Delete existing protocols (will be regenerated)
      await ctx.runMutation(api.protocols.deleteByCorridorId, { corridorId });

      // Run full pipeline
      const result = await ctx.runAction(api.ai.pipeline.generateCorridorProtocols, {
        corridorId,
        forceRefresh: true,
      });

      // Update status to fresh
      await ctx.runMutation(internal.corridors.updateResearchStatus, {
        corridorId,
        status: "fresh",
        protocolCount: result.protocolIds.length,
      });

      // Log metric
      await ctx.runMutation(api.metrics.logEvent, {
        event: "corridor_refreshed",
        corridorId,
        metadata: { protocolCount: result.protocolIds.length },
      });

      return { success: true, protocolCount: result.protocolIds.length };
    } catch (error) {
      // Update status to error
      await ctx.runMutation(internal.corridors.updateResearchStatus, {
        corridorId,
        status: "error",
        errorMessage: error.message,
      });

      // Log error metric
      await ctx.runMutation(api.metrics.logEvent, {
        event: "corridor_refresh_error",
        corridorId,
        metadata: { error: error.message },
      });

      throw error;
    }
  },
});

// Internal mutation for status updates
export const updateResearchStatus = internalMutation({
  args: {
    corridorId: v.id("corridors"),
    status: v.string(),
    protocolCount: v.optional(v.number()),
    errorMessage: v.optional(v.string()),
  },
  handler: async (ctx, { corridorId, status, protocolCount, errorMessage }) => {
    await ctx.db.patch(corridorId, {
      researchStatus: status as any,
      lastResearchedAt: status === "fresh" ? Date.now() : undefined,
      protocolCount,
      errorMessage,
      updatedAt: Date.now(),
    });
  },
});
```

### Stale Protocol Handler with Scheduler
[Source: architecture.md#backend-architecture]

```typescript
// convex/protocols.ts - Add trigger for background refresh
import { query, action } from "./_generated/server";
import { v } from "convex/values";

export const getProtocolsAndRefreshIfStale = action({
  args: { corridorId: v.id("corridors") },
  handler: async (ctx, { corridorId }) => {
    // Get current protocols and freshness
    const result = await ctx.runQuery(api.protocols.getProtocolsWithFreshness, {
      corridorId,
    });

    if (!result) {
      throw new Error("Corridor not found");
    }

    // If stale and not already refreshing, schedule background refresh
    if (result.freshness.isStale && !result.freshness.refreshing) {
      // Log cache miss
      await ctx.runMutation(api.metrics.logEvent, {
        event: "cache_miss",
        corridorId,
        metadata: { isStale: true },
      });

      // Schedule background refresh (non-blocking)
      await ctx.scheduler.runAfter(0, api.ai.refresh.refreshCorridorInBackground, {
        corridorId,
      });
    } else {
      // Log cache hit
      await ctx.runMutation(api.metrics.logEvent, {
        event: "cache_hit",
        corridorId,
        metadata: { isFresh: !result.freshness.isStale },
      });
    }

    // Return cached data immediately
    return result;
  },
});
```

### Admin Refresh Function
```typescript
// convex/admin.ts
import { mutation, action } from "./_generated/server";
import { v } from "convex/values";
import { api } from "./_generated/api";

export const forceRefreshCorridor = action({
  args: { corridorId: v.id("corridors") },
  handler: async (ctx, { corridorId }) => {
    // Verify corridor exists
    const corridor = await ctx.runQuery(api.corridors.getCorridor, {
      id: corridorId,
    });

    if (!corridor) {
      throw new Error("Corridor not found");
    }

    console.log(`Force refreshing corridor: ${corridor.origin} → ${corridor.destination}`);

    // Run refresh immediately (blocking)
    const result = await ctx.runAction(api.ai.refresh.refreshCorridorInBackground, {
      corridorId,
    });

    return {
      success: true,
      corridorId,
      origin: corridor.origin,
      destination: corridor.destination,
      protocolCount: result.protocolCount,
    };
  },
});
```

### Metrics Logging
```typescript
// convex/metrics.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

// Add to schema.ts:
// metrics: defineTable({
//   event: v.string(),
//   corridorId: v.optional(v.id("corridors")),
//   metadata: v.optional(v.any()),
//   createdAt: v.number(),
// })
//   .index("by_event", ["event"])
//   .index("by_corridor", ["corridorId"])

export const logEvent = mutation({
  args: {
    event: v.string(),
    corridorId: v.optional(v.id("corridors")),
    metadata: v.optional(v.any()),
  },
  handler: async (ctx, { event, corridorId, metadata }) => {
    await ctx.db.insert("metrics", {
      event,
      corridorId,
      metadata,
      createdAt: Date.now(),
    });
  },
});

export const getCacheMetrics = query({
  args: { since: v.optional(v.number()) },
  handler: async (ctx, { since }) => {
    const cutoff = since ?? Date.now() - 24 * 60 * 60 * 1000; // Last 24h

    const allMetrics = await ctx.db.query("metrics").collect();
    const recent = allMetrics.filter((m) => m.createdAt >= cutoff);

    const hits = recent.filter((m) => m.event === "cache_hit").length;
    const misses = recent.filter((m) => m.event === "cache_miss").length;
    const refreshes = recent.filter((m) => m.event === "corridor_refreshed").length;
    const errors = recent.filter((m) => m.event === "corridor_refresh_error").length;

    return {
      cacheHits: hits,
      cacheMisses: misses,
      hitRate: hits + misses > 0 ? hits / (hits + misses) : 0,
      refreshes,
      errors,
      period: "24h",
    };
  },
});
```

### Scheduled Cleanup Cron
[Source: architecture.md#backend-architecture]

```typescript
// convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Daily cleanup of expired content
crons.daily(
  "cleanup expired content",
  { hourUTC: 3, minuteUTC: 0 }, // 3 AM UTC
  internal.maintenance.cleanupExpiredContent
);

// Daily pre-emptive refresh of stale popular corridors
crons.daily(
  "refresh stale corridors",
  { hourUTC: 4, minuteUTC: 0 }, // 4 AM UTC
  internal.maintenance.refreshStaleCorridors
);

export default crons;
```

```typescript
// convex/maintenance.ts
import { internalAction, internalMutation } from "./_generated/server";
import { api, internal } from "./_generated/api";

export const cleanupExpiredContent = internalMutation({
  args: {},
  handler: async (ctx) => {
    const now = Date.now();

    // Find expired content
    const expired = await ctx.db
      .query("ingestedContent")
      .withIndex("by_expiry")
      .filter((q) => q.lt(q.field("expiresAt"), now))
      .collect();

    // Delete expired entries
    for (const content of expired) {
      await ctx.db.delete(content._id);
    }

    console.log(`Cleaned up ${expired.length} expired content entries`);
    return { deleted: expired.length };
  },
});

export const refreshStaleCorridors = internalAction({
  args: {},
  handler: async (ctx) => {
    // Find corridors that are stale
    const corridors = await ctx.runQuery(internal.corridors.getStaleCorridors, {
      limit: 5, // Limit to prevent overload
    });

    for (const corridor of corridors) {
      try {
        await ctx.runAction(api.ai.refresh.refreshCorridorInBackground, {
          corridorId: corridor._id,
        });
      } catch (error) {
        console.error(`Failed to refresh corridor ${corridor._id}:`, error);
      }
    }

    return { refreshed: corridors.length };
  },
});
```

### Metrics Schema Addition
```typescript
// Add to convex/schema.ts
metrics: defineTable({
  event: v.string(),
  corridorId: v.optional(v.id("corridors")),
  metadata: v.optional(v.any()),
  createdAt: v.number(),
})
  .index("by_event", ["event"])
  .index("by_corridor", ["corridorId"])
  .index("by_time", ["createdAt"]),
```

### File Structure
```
convex/
├── schema.ts              # Add metrics table, update corridors
├── corridors.ts           # Add freshness queries
├── protocols.ts           # Add cache-first retrieval
├── admin.ts               # Admin functions
├── metrics.ts             # Metrics logging
├── crons.ts               # Scheduled jobs
├── maintenance.ts         # Cleanup functions
└── ai/
    └── refresh.ts         # Background refresh

lib/
└── constants/
    └── freshness.ts       # Freshness thresholds
```

### Dependencies from Previous Stories
- Story 2.1: Corridors and Protocols tables
- Story 2.3: Research action
- Story 2.4: Synthesis pipeline

---

## Testing

### Test Scenarios

1. **Freshness Check**
   - [ ] New corridor: isStale = true
   - [ ] Recently researched: isStale = false
   - [ ] 31 days old: isStale = true

2. **Cache-First Retrieval**
   - [ ] Fresh corridor: returns immediately, no refresh
   - [ ] Stale corridor: returns cached, triggers background refresh
   - [ ] Refreshing corridor: returns cached, no duplicate refresh

3. **Background Refresh**
   - [ ] Status changes: stale → refreshing → fresh
   - [ ] Error handling: refreshing → error with message
   - [ ] Protocols replaced on success

4. **Admin Force Refresh**
   - [ ] Bypasses freshness check
   - [ ] Runs synchronously
   - [ ] Returns new protocol count

5. **Metrics**
   - [ ] Cache hits logged
   - [ ] Cache misses logged
   - [ ] getCacheMetrics returns accurate counts

6. **Cron Jobs**
   - [ ] Expired content cleaned up
   - [ ] Stale corridors refreshed

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-21 | 1.0 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*
