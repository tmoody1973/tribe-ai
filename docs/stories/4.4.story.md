# Story 4.4: Perplexity Fallback for Real-time Queries

## Status

**Completed**

---

## Story

**As a** system,
**I want** to query Perplexity for real-time or policy questions,
**so that** users get current information not in cached knowledge.

---

## Acceptance Criteria

1. Query classifier detects real-time/policy questions (e.g., "current processing times")
2. Perplexity API called for qualifying queries
3. Perplexity results integrated into Claude synthesis
4. Source attribution includes Perplexity search results
5. Fallback triggers when RAG confidence is low
6. Rate limiting applied to Perplexity calls
7. Perplexity usage logged for cost tracking

---

## Tasks / Subtasks

- [x] **Task 1: Create Query Classifier** (AC: 1)
  - [x] Create `lib/queryClassifier.ts`
  - [x] Define real-time query patterns
  - [x] Use regex for classification
  - [x] Return classification result with confidence

- [x] **Task 2: Create Perplexity Client** (AC: 2)
  - [x] Create `lib/perplexity.ts`
  - [x] `PERPLEXITY_API_KEY` already in environment
  - [x] Implement search function with sonar model
  - [x] Handle API responses and citations

- [x] **Task 3: Implement Perplexity Action** (AC: 2, 3)
  - [x] Create `convex/ai/perplexity.ts`
  - [x] Implement `searchRealtime` action
  - [x] Format results for synthesis
  - [x] Include source URLs with type "perplexity"

- [x] **Task 4: Add Source Attribution** (AC: 4)
  - [x] Parse Perplexity citations
  - [x] Mark sources as "perplexity" type
  - [x] Instruction to mark as "[Real-time]" in ChatWindow

- [x] **Task 5: Implement Confidence Check** (AC: 5)
  - [x] Query classification with isRealtime/isPolicyRelated flags
  - [x] shouldUsePerplexity helper function (for future use)
  - [x] CopilotKit action checks classification before calling Perplexity

- [x] **Task 6: Add Rate Limiting** (AC: 6)
  - [x] Create `convex/rateLimits.ts` (Convex-based, no Upstash needed)
  - [x] Set per-user rate limits (10 per hour)
  - [x] Handle limit exceeded gracefully with message

- [x] **Task 7: Log Perplexity Usage** (AC: 7)
  - [x] Track API calls via tokenUsage table
  - [x] Log input/output tokens
  - [x] Monitor via existing monitoring infrastructure

---

## Dev Notes

### Query Classifier
[Source: architecture.md#core-workflows]

```typescript
// lib/queryClassifier.ts

interface ClassificationResult {
  isRealtime: boolean;
  isPolicyRelated: boolean;
  confidence: number;
  reason: string;
}

// Real-time query patterns
const REALTIME_PATTERNS = [
  /current(ly)?|right now|today|this (week|month|year)/i,
  /latest|newest|most recent|updated?/i,
  /processing time|wait time|how long/i,
  /open|closed|available|accepting/i,
  /price|cost|fee.*\d{4}/i, // Prices with year
  /policy change|new (rule|law|regulation)/i,
  /embassy.*appointment/i,
  /visa.*slot/i,
];

// Policy-related patterns
const POLICY_PATTERNS = [
  /visa (requirement|rule|policy|regulation)/i,
  /immigration (law|policy|change)/i,
  /permit (requirement|application)/i,
  /legal requirement/i,
  /government (announcement|update)/i,
  /official (requirement|document)/i,
];

export function classifyQuery(query: string): ClassificationResult {
  const isRealtime = REALTIME_PATTERNS.some((pattern) => pattern.test(query));
  const isPolicyRelated = POLICY_PATTERNS.some((pattern) => pattern.test(query));

  let confidence = 0;
  let reason = "";

  if (isRealtime) {
    confidence += 0.5;
    reason = "Query contains real-time indicators";
  }

  if (isPolicyRelated) {
    confidence += 0.3;
    reason += (reason ? "; " : "") + "Query is policy-related";
  }

  // Check for question words that suggest current information needed
  if (/\b(what is|how much|when can|where to)\b/i.test(query)) {
    confidence += 0.2;
  }

  return {
    isRealtime,
    isPolicyRelated,
    confidence: Math.min(confidence, 1),
    reason: reason || "Standard knowledge query",
  };
}

export function shouldUsePerplexity(
  classification: ClassificationResult,
  ragConfidence: number
): boolean {
  // Use Perplexity if:
  // 1. Query is classified as real-time/policy with high confidence
  // 2. OR RAG confidence is low (< 0.5)
  return (
    (classification.isRealtime && classification.confidence > 0.5) ||
    (classification.isPolicyRelated && classification.confidence > 0.5) ||
    ragConfidence < 0.5
  );
}
```

### Perplexity Client
```typescript
// lib/perplexity.ts

interface PerplexityMessage {
  role: "system" | "user" | "assistant";
  content: string;
}

interface PerplexityResponse {
  id: string;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content: string;
    };
    finish_reason: string;
  }>;
  citations?: string[];
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
  };
}

const PERPLEXITY_API_URL = "https://api.perplexity.ai/chat/completions";

export async function searchPerplexity(
  query: string,
  context?: { origin?: string; destination?: string }
): Promise<{
  answer: string;
  citations: string[];
  usage: { input: number; output: number };
}> {
  const apiKey = process.env.PERPLEXITY_API_KEY;
  if (!apiKey) {
    throw new Error("PERPLEXITY_API_KEY not configured");
  }

  const systemPrompt = context
    ? `You are researching migration information for someone moving from ${context.origin} to ${context.destination}. Focus on current, official information.`
    : "You are researching migration and visa information. Focus on current, official sources.";

  const messages: PerplexityMessage[] = [
    { role: "system", content: systemPrompt },
    { role: "user", content: query },
  ];

  const response = await fetch(PERPLEXITY_API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: "llama-3.1-sonar-small-128k-online",
      messages,
      return_citations: true,
    }),
  });

  if (!response.ok) {
    throw new Error(`Perplexity API error: ${response.status}`);
  }

  const data: PerplexityResponse = await response.json();

  return {
    answer: data.choices[0]?.message.content ?? "",
    citations: data.citations ?? [],
    usage: {
      input: data.usage.prompt_tokens,
      output: data.usage.completion_tokens,
    },
  };
}
```

### Perplexity Action with Rate Limiting
```typescript
// convex/ai/perplexity.ts
import { action } from "../_generated/server";
import { v } from "convex/values";
import { api } from "../_generated/api";
import { searchPerplexity } from "../../lib/perplexity";
import { Redis } from "@upstash/redis";
import { Ratelimit } from "@upstash/ratelimit";

// Rate limiter: 10 requests per hour per user
const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, "1 h"),
  analytics: true,
});

interface PerplexityResult {
  answer: string;
  sources: Array<{
    url: string;
    type: "perplexity";
  }>;
  rateLimited: boolean;
}

export const searchRealtime = action({
  args: {
    query: v.string(),
    corridorId: v.id("corridors"),
    userId: v.string(),
  },
  handler: async (ctx, { query, corridorId, userId }): Promise<PerplexityResult> => {
    const startTime = Date.now();

    // Check rate limit
    const { success, remaining } = await ratelimit.limit(userId);

    if (!success) {
      console.log(`Rate limited user ${userId}, ${remaining} requests remaining`);
      return {
        answer: "",
        sources: [],
        rateLimited: true,
      };
    }

    // Get corridor for context
    const corridor = await ctx.runQuery(api.corridors.getCorridor, {
      id: corridorId,
    });

    try {
      const result = await searchPerplexity(query, {
        origin: corridor?.origin,
        destination: corridor?.destination,
      });

      // Log usage
      await ctx.runMutation(api.monitoring.logTokenUsage, {
        model: "perplexity-sonar",
        inputTokens: result.usage.input,
        outputTokens: result.usage.output,
        action: "perplexity_search",
        corridorId,
      });

      console.log(`Perplexity search completed in ${Date.now() - startTime}ms`);

      return {
        answer: result.answer,
        sources: result.citations.map((url) => ({
          url,
          type: "perplexity" as const,
        })),
        rateLimited: false,
      };
    } catch (error) {
      console.error("Perplexity search error:", error);
      throw error;
    }
  },
});
```

### Enhanced Synthesis with Perplexity
```typescript
// convex/ai/qa.ts - Updated synthesizeAnswer

export const synthesizeAnswerWithFallback = action({
  args: {
    question: v.string(),
    corridorId: v.id("corridors"),
    language: v.optional(v.string()),
    userId: v.string(),
  },
  handler: async (ctx, { question, corridorId, language = "en", userId }) => {
    const startTime = Date.now();

    // Step 1: Classify query
    const classification = classifyQuery(question);

    // Step 2: Retrieve from RAG
    const searchResults = await ctx.runAction(api.ai.search.searchRelevantContent, {
      query: question,
      corridorId,
      limit: 10,
    });

    // Calculate RAG confidence (average of top 3 scores)
    const ragConfidence =
      searchResults.slice(0, 3).reduce((sum, r) => sum + r.score, 0) / 3;

    // Step 3: Check if Perplexity needed
    let perplexityResult = null;
    if (shouldUsePerplexity(classification, ragConfidence)) {
      console.log("Using Perplexity fallback:", classification.reason);

      perplexityResult = await ctx.runAction(api.ai.perplexity.searchRealtime, {
        query: question,
        corridorId,
        userId,
      });
    }

    // Step 4: Build combined context
    const ragContext = buildContext(searchResults);
    const perplexityContext = perplexityResult?.answer
      ? `\n\n[Real-time information from Perplexity]:\n${perplexityResult.answer}`
      : "";

    const fullContext = ragContext + perplexityContext;

    // Step 5: Synthesize with all sources
    const allSources = [
      ...buildSourcesList(searchResults).map((s) => ({ ...s, type: "community" as const })),
      ...(perplexityResult?.sources ?? []).map((s, i) => ({
        index: searchResults.length + i + 1,
        url: s.url,
        type: "perplexity" as const,
      })),
    ];

    // Generate synthesis...
    const corridor = await ctx.runQuery(api.corridors.getCorridor, {
      id: corridorId,
    });

    const prompt = buildPromptWithPerplexity(
      question,
      fullContext,
      corridor,
      language,
      perplexityResult !== null
    );

    const result = await qaAdvisor.generate(prompt);

    return {
      answer: formatAnswer(result.text, allSources),
      sources: allSources,
      usedPerplexity: perplexityResult !== null,
      wasRateLimited: perplexityResult?.rateLimited ?? false,
      classification,
      latencyMs: Date.now() - startTime,
    };
  },
});

function buildPromptWithPerplexity(
  question: string,
  context: string,
  corridor: { origin: string; destination: string } | null,
  language: string,
  hasPerplexity: boolean
): string {
  const basePrompt = buildPrompt(question, context, corridor, language);

  if (hasPerplexity) {
    return (
      basePrompt +
      `\n\nNote: The context includes real-time information from web search. Prioritize this for questions about current policies, processing times, or recent changes. Mark these sources as "Real-time" in your attribution.`
    );
  }

  return basePrompt;
}
```

### Translation Keys
```json
// messages/en.json - Add Perplexity-related keys
{
  "chat": {
    "realtimeSource": "Real-time web search",
    "communitySource": "Community knowledge",
    "rateLimited": "You've reached the limit for real-time searches. Try again later.",
    "perplexityNote": "This answer includes real-time information that may be more current than our cached knowledge."
  }
}
```

### File Structure
```
lib/
├── queryClassifier.ts    # Query classification
└── perplexity.ts         # Perplexity API client

convex/
└── ai/
    ├── perplexity.ts     # Perplexity action
    └── qa.ts             # Enhanced synthesis
```

### Dependencies from Previous Stories
- Story 4.2: RAG retrieval for confidence scoring
- Story 4.3: Claude synthesis (to enhance)

---

## Testing

### Test Scenarios

1. **Query Classification**
   - [ ] "What's the current visa processing time?" → real-time
   - [ ] "How did you move to Germany?" → not real-time
   - [ ] "New immigration policy 2025" → policy + real-time

2. **Perplexity Integration**
   - [ ] API called for qualifying queries
   - [ ] Citations extracted from response
   - [ ] Results merged into synthesis

3. **Rate Limiting**
   - [ ] 10 requests per hour per user
   - [ ] Graceful message when limited
   - [ ] Still returns RAG results

4. **Source Attribution**
   - [ ] Perplexity sources marked as "Real-time"
   - [ ] Community sources marked as "Community"
   - [ ] All URLs valid and clickable

5. **Confidence Fallback**
   - [ ] Low RAG score triggers Perplexity
   - [ ] Combined answer uses both sources
   - [ ] Logging captures fallback reason

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-21 | 1.0 | Initial story draft | Bob (SM) |

---

## Dev Agent Record

**Completed:** 2025-12-23

### Files Created
- `lib/queryClassifier.ts` - Query classification for real-time/policy detection
- `lib/perplexity.ts` - Perplexity API client
- `convex/ai/perplexity.ts` - Perplexity search action with rate limiting
- `convex/rateLimits.ts` - Convex-based rate limiting (no external dependency)

### Files Modified
- `convex/schema.ts` - Added rateLimits table
- `app/api/copilotkit/route.ts` - Added searchRealtimeInfo action
- `components/chat/ChatWindow.tsx` - Updated instructions for real-time tool usage
- `messages/en.json` - Added real-time source translations

### Implementation Notes
- Used Convex-based rate limiting instead of Upstash Redis (simpler, no new dependency)
- Rate limit: 10 Perplexity requests per hour per user
- Query classifier uses regex patterns for real-time/policy detection
- Perplexity uses sonar model with citations
- CopilotKit action `searchRealtimeInfo` integrates with chat
- Token usage logged to existing monitoring infrastructure

### Key Functions
- `classifyQuery` - Detects real-time and policy-related queries
- `searchPerplexity` - API client for Perplexity
- `searchRealtime` - Convex action with rate limiting
- `checkRateLimit` / `incrementRateLimit` - Rate limit management

### Build Status
- TypeScript: ✅ Passed
- Next.js build: ✅ Passed
- Convex deploy: ✅ Deployed

---

## QA Results
*To be filled by QA Agent*
